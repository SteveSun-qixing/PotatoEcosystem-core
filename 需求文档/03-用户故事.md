# 薯片微内核 - 用户故事

**版本**: 1.0.0  
**更新日期**: 2026-01-31  
**状态**: 全新设计

---

> **说明**：本文档中的"用户"指的是基于薯片内核开发功能模块的开发者，而非最终使用软件的用户。

## 3.1 模块开发者故事

### US-001：快速开始开发第一个模块

**角色**：新手模块开发者  
**目标**：在2小时内开发出第一个能运行的模块  
**场景**：

小李是一个前端开发者，听说了薯片生态，想尝试开发一个简单的图片滤镜卡片插件。

1. 他访问薯片开发者文档，找到"快速开始"指南
2. 使用脚手架工具创建模块项目：
   ```bash
   chips create-module image-filter
   ```
3. 工具自动生成项目结构、配置文件、示例代码
4. 他在生成的模板基础上，添加了图片滤镜的核心逻辑（20行代码）
5. 配置 `module.yaml`，声明模块处理 `applyImageFilter` action
6. 运行 `chips dev` 启动开发模式，内核自动加载他的模块
7. 通过内核发送测试请求，调用他的模块
8. 模块接收请求，应用滤镜，返回处理结果
9. 整个过程只用了1.5小时

**验收标准**：
- ✅ 脚手架工具能快速生成模块模板
- ✅ 模板代码有清晰的注释和示例
- ✅ 开发模式下模块热加载，修改代码立即生效
- ✅ 内核能正确路由请求到新模块
- ✅ 有详细的错误提示和调试日志

### US-002：模块间通信

**角色**：模块开发者  
**目标**：实现两个模块之间的数据交互  
**场景**：

小王在开发视频卡片编辑器时，需要调用视频处理模块来生成预览图。

1. 他在视频编辑器模块中，向内核发送路由请求：
```javascript
const response = await chips.route({
  action: 'generateThumbnail',
  target: 'video-processor',
  params: {
    videoPath: '/path/to/video.mp4',
    timestamp: 10.5
  }
});

const thumbnailPath = response.data.thumbnailPath;
```

2. 内核接收请求，验证格式和权限
3. 内核查找路由表，找到 `video-processor` 模块
4. 内核转发请求到视频处理模块
5. 视频处理模块处理请求，生成缩略图，返回响应
6. 内核将响应转发回视频编辑器模块
7. 视频编辑器获得缩略图路径，显示在界面上

整个过程中，两个模块完全不知道对方的存在，只通过内核交互。

**验收标准**：
- ✅ SDK 提供简单的 API 发送路由请求
- ✅ 支持同步和异步调用
- ✅ 自动处理请求超时
- ✅ 错误信息清晰（如目标模块不存在、请求格式错误等）
- ✅ 提供调试工具查看路由过程

### US-003：声明模块依赖

**角色**：插件开发者  
**目标**：开发依赖其他模块的插件  
**场景**：

小赵在开发视频卡片查看器，需要依赖视频解码器模块和字幕渲染器模块。

1. 他在 `module.yaml` 中声明依赖：
```yaml
dependencies:
  - id: video-decoder
    version: "^1.2.0"
  - id: subtitle-renderer
    version: ">=2.0.0 <3.0.0"
```

2. 用户安装视频卡片查看器插件
3. 内核检查依赖，发现 `video-decoder` 未安装
4. 内核提示用户需要安装依赖模块，并提供安装链接
5. 用户确认安装
6. 内核安装 `video-decoder` 1.2.3版本（符合 `^1.2.0` 要求）
7. 检查 `subtitle-renderer`，已安装2.1.0版本（符合要求）
8. 所有依赖满足，加载视频卡片查看器
9. 小赵的模块可以直接调用依赖模块的功能

**验收标准**：
- ✅ 支持语义化版本范围声明
- ✅ 自动检查依赖关系
- ✅ 友好的依赖缺失提示
- ✅ 检测循环依赖并报错
- ✅ 依赖模块自动加载

### US-004：使用事件系统

**角色**：模块开发者  
**目标**：通过事件系统实现模块间松耦合通信  
**场景**：

小孙开发了一个文件监控模块，需要在文件变化时通知其他模块。

1. 他的模块在启动时发布事件：
```javascript
// 订阅文件变化事件
await chips.eventBus.subscribe('file.changed', (event) => {
  console.log('File changed:', event.data.filePath);
  // 处理文件变化
});
```

2. 文件监控模块检测到文件变化时，发布事件：
```javascript
chips.eventBus.publish({
  type: 'file.changed',
  data: {
    filePath: '/path/to/file.txt',
    changeType: 'modified'
  }
});
```

3. 内核的事件总线接收事件
4. 查找所有订阅了 `file.changed` 的模块
5. 并发向所有订阅者发送事件
6. 小孙的模块收到事件，执行相应处理

**验收标准**：
- ✅ 简单的事件发布订阅 API
- ✅ 支持并发分发
- ✅ 不阻塞发布者
- ✅ 订阅者异常不影响其他订阅者

### US-005：使用配置管理

**角色**：模块开发者  
**目标**：读取和管理模块配置  
**场景**：

小钱开发视频播放器模块，需要可配置的播放参数。

1. 他在模块中读取配置：
```javascript
const autoPlay = chips.config.get('video-player.autoPlay', true);
const defaultVolume = chips.config.get('video-player.volume', 0.8);
```

2. 用户在配置文件中修改设置：
```yaml
# config/user-config.yaml
video-player:
  autoPlay: false
  volume: 0.5
```

3. 模块监听配置变化：
```javascript
chips.config.onChange('video-player', (newConfig) => {
  console.log('Config changed:', newConfig);
  // 更新播放器设置
  player.setAutoPlay(newConfig.autoPlay);
  player.setVolume(newConfig.volume);
});
```

4. 用户修改配置并保存
5. 内核检测到配置变化
6. 通知所有监听该配置的模块
7. 小钱的模块收到通知，自动更新设置

**验收标准**：
- ✅ 简单的配置读写 API
- ✅ 支持默认值
- ✅ 支持嵌套路径访问
- ✅ 支持配置变更监听
- ✅ 自动持久化

### US-006：开发跨模块的复杂功能

**角色**：高级开发者  
**目标**：开发需要多个模块协作的复杂功能  
**场景**：

小周在开发智能视频摘要生成器，需要协调多个模块：
- 文件识别模块（Foundation）：识别视频文件
- 视频解码器：提取视频帧
- 图像识别模块：识别关键帧
- AI模块：生成摘要文本

1. 他的模块首先请求识别文件类型（路由到 Foundation）：
```javascript
const fileInfo = await chips.route({
  action: 'identifyFile',
  params: { filePath: videoPath }
});
```

2. 然后请求视频解码器提取所有帧：
```javascript
const frames = await chips.route({
  action: 'extractFrames',
  target: 'video-decoder',
  params: { videoPath, interval: 5 }
});
```

3. 请求图像识别模块分析每一帧：
```javascript
const keyFrames = [];
for (const frame of frames.data) {
  const result = await chips.route({
    action: 'analyzeImage',
    target: 'image-recognizer',
    params: { imagePath: frame.path }
  });
  if (result.data.isKeyFrame) {
    keyFrames.push(frame);
  }
}
```

4. 最后请求AI模块生成摘要：
```javascript
const summary = await chips.route({
  action: 'generateSummary',
  target: 'ai-module',
  params: {
    frames: keyFrames,
    context: 'video'
  }
});
```

整个过程中，各个模块独立工作，通过内核协调。

**验收标准**：
- ✅ 支持异步和并发请求
- ✅ 路由性能高，不成为瓶颈
- ✅ 清晰的错误处理
- ✅ 支持请求链路追踪

## 3.2 编辑引擎/查看器开发者故事

### US-007：基于内核开发完整应用

**角色**：应用开发者  
**目标**：基于薯片内核开发卡片编辑引擎  
**场景**：

小吴的团队要开发卡片编辑引擎，这是一个完整的应用程序。

1. 项目初始化，引入薯片内核 SDK
2. 启动内核：
```javascript
const core = await ChipsCore.initialize({
  modulePath: './modules',
  configPath: './config'
});
```

3. 注册必需的 Foundation 模块：
```javascript
await core.registerFoundationModules([
  'file-identifier',
  'resource-manager',
  'zip-processor',
  'window-manager'
]);
```

4. 加载应用模块：
```javascript
await core.loadModule('file-manager');
await core.loadModule('desktop-canvas');
await core.loadModule('card-editor-ui');
```

5. 监听用户操作：
```javascript
core.on('file-dropped', async (event) => {
  const files = event.data.files;
  // 内核路由到 Foundation 的文件识别，再路由到对应处理器
  for (const file of files) {
    await core.route({
      action: 'importFile',
      params: { filePath: file.path }
    });
  }
});
```

6. 用户创建新卡片：
```javascript
core.route({
  action: 'createCard',
  target: 'card-manager',
  params: { type: 'video' }
});
```

7. 内核路由到视频卡片编辑器插件
8. 插件创建卡片，显示编辑界面
9. 用户编辑完成，保存卡片
10. 保存请求通过内核路由到 Foundation 的资源管理器

**验收标准**：
- ✅ 内核提供完整的应用开发 API
- ✅ 支持模块按需加载
- ✅ 提供事件监听机制
- ✅ 自动处理模块间的复杂交互
- ✅ 应用代码简洁，无需处理底层细节

### US-008：调试和监控

**角色**：应用开发者  
**目标**：调试模块间的通信问题  
**场景**：

小郑在开发查看器时，发现某个卡片加载失败。

1. 他启用调试模式：
```javascript
const core = await ChipsCore.initialize({
  debug: true,
  logLevel: 'DEBUG'
});
```

2. 内核输出详细的路由日志：
```
[DEBUG] Route request: sender=card-loader, action=loadCard, target=video-card
[DEBUG] Route table lookup: action=loadCard -> video-card
[DEBUG] Forward request to video-card, request_id=abc123
[DEBUG] video-card processing request...
[ERROR] video-card error: FileNotFound - /path/to/video.mp4
[DEBUG] Return error response: status=404
```

3. 他使用路由追踪工具：
```bash
chips-debug trace-route --request-id=abc123
```

4. 工具显示完整的路由链路：
```
card-loader -> core -> video-card -> core -> file-identifier (Foundation)
                                              ↓ error: FileNotFound
                                  core <- video-card <- core <- card-loader
```

5. 他发现是文件路径错误，修复后问题解决

**验收标准**：
- ✅ 调试模式输出详细日志
- ✅ 日志包含完整的调用链路
- ✅ 提供路由追踪工具
- ✅ 错误信息清晰，易于定位问题

## 3.3 插件市场/分发者故事

### US-009：打包插件供用户安装

**角色**：插件开发者  
**目标**：将开发好的插件打包发布  
**场景**：

小钱开发完成了一个优秀的视频卡片插件，想发布到插件市场。

1. 他完成开发和测试
2. 运行打包命令：
```bash
chips build --type=plugin
```

3. 工具自动：
   - 验证 module.yaml 配置
   - 检查依赖关系
   - 运行测试套件
   - 压缩代码和资源
   - 生成插件包：`video-card-plugin-1.0.0.cspkg`

4. 他上传插件包到插件市场
5. 用户在编辑引擎中浏览插件市场，找到他的插件
6. 用户点击安装
7. 内核下载插件包，验证签名，解压到模块目录
8. 内核读取 module.yaml，注册插件
9. 插件立即可用，无需重启

**验收标准**：
- ✅ 简单的打包命令
- ✅ 自动验证插件完整性
- ✅ 标准的插件包格式
- ✅ 支持热安装
- ✅ 安装失败时友好的错误提示

### US-010：更新已安装的插件

**角色**：插件开发者  
**目标**：发布插件更新  
**场景**：

小钱发现视频卡片插件有个bug，修复后发布1.0.1版本。

1. 他修复bug，更新版本号到1.0.1
2. 打包发布新版本
3. 用户的编辑引擎检测到插件有更新
4. 用户点击"更新插件"
5. 内核下载新版本
6. 内核卸载旧版本（1.0.0）
7. 内核安装新版本（1.0.1）
8. 用户正在编辑的卡片无缝切换到新版本

**验收标准**：
- ✅ 支持热更新插件
- ✅ 保留用户数据和配置
- ✅ 更新失败时可回滚
- ✅ 更新过程中不影响其他功能

## 3.4 软件制作者故事

### US-011：制作独立软件

**角色**：软件制作者  
**目标**：基于薯片内核制作独立软件  
**场景**：

小侯想制作一个待办事项管理软件，只包含待办卡片功能。

1. 他使用软件制作器工具：
```bash
chips-maker create --name="待办清单" --type=standalone
```

2. 在配置文件中指定需要的模块：
```yaml
modules:
  - window-frame        # 窗口框架
  - todo-card          # 待办卡片插件
  - file-manager       # 文件管理
```

3. 运行打包命令：
```bash
chips-maker build --platform=macos,windows,linux
```

4. 工具分析依赖，打包内核+Foundation（必需部分）+指定模块
5. 生成独立应用程序：
   - `TodoList.app`（macOS，约150MB）
   - `TodoList.exe`（Windows，约150MB）
   - `todolist`（Linux，约150MB）

6. 用户下载安装，无需安装薯片内核
7. 软件启动，内核加载待办卡片模块
8. 用户只看到待办功能，体验就是一个专门的待办软件

**验收标准**：
- ✅ 简单的软件制作流程
- ✅ 自动分析和打包依赖
- ✅ 支持跨平台打包
- ✅ 生成的软件完全独立，可直接运行
- ✅ 软件体积优化，只包含必需组件

### US-012：使用共享内核模式

**角色**：软件制作者  
**目标**：制作共享内核模式的软件  
**场景**：

小侯还想制作一个笔记软件，使用共享内核模式。

1. 使用软件制作器：
```bash
chips-maker create --name="薯片笔记" --type=shared-core
```

2. 指定模块：
```yaml
modules:
  - markdown-card
  - richtext-card
  - image-card
  - notebook-ui
```

3. 打包：
```bash
chips-maker build --mode=shared-core
```

4. 生成的包只有约5MB，包含：
   - 模块文件
   - 配置文件
   - 快捷方式

5. 安装时，检查用户设备是否有薯片内核
6. 没有则提示安装内核（一次性，所有薯片软件共享）
7. 将模块注册到内核
8. 创建桌面快捷方式：
```bash
chips-core --app=note-app
```

9. 用户双击快捷方式，内核启动并加载笔记软件模块
10. 如果用户同时运行待办和笔记软件，共享同一个内核进程，节省资源

**验收标准**：
- ✅ 软件包体积小（~5MB）
- ✅ 自动检测和安装共享内核
- ✅ 多个软件共享内核，节省资源
- ✅ 用户体验不受影响（感觉像独立软件）

## 3.5 系统集成者故事

### US-013：在脚本中使用薯片内核

**角色**：系统管理员/自动化工程师  
**目标**：在脚本中批量处理任务  
**场景**：

小何需要批量转换一批卡片文件的格式。

1. 他在Shell脚本中调用内核CLI：
```bash
#!/bin/bash
for file in *.card; do
  chips-core process \
    --input="$file" \
    --action=convertFormat \
    --params='{"targetVersion":"2.0"}' \
    --output="converted/$file"
done
```

2. 内核启动，加载格式转换模块
3. 处理每个文件（通过路由调用 Foundation 和转换模块）
4. 输出转换结果
5. 脚本可以集成到CI/CD流程

**验收标准**：
- ✅ 提供CLI接口
- ✅ 支持非交互模式
- ✅ 支持批量处理
- ✅ 清晰的输出和错误信息
- ✅ 返回标准退出码

### US-014：集成到现有系统

**角色**：系统集成工程师  
**目标**：将薯片内核集成到现有内容管理系统  
**场景**：

小秦的公司有一个内容管理系统，想集成薯片卡片支持。

1. 他在系统后端引入内核库：
```python
from chips_core import ChipsCore

core = ChipsCore.initialize({
    'module_path': './chips-modules',
    'mode': 'embedded'
})
```

2. 用户上传卡片文件时：
```python
def handle_upload(card_file):
    # 验证文件（路由到 Foundation）
    result = core.route({
        'action': 'identifyFile',
        'params': {'filePath': card_file}
    })
    
    if not result.data.isValid:
        return {'error': 'Invalid card file'}
    
    # 提取元数据（路由到相应的卡片处理模块）
    metadata = core.route({
        'action': 'extractMetadata',
        'params': {'cardPath': card_file}
    })
    
    # 保存到数据库
    save_to_database(metadata.data)
    
    return {'success': True, 'metadata': metadata.data}
```

3. 生成卡片预览：
```python
def generate_preview(card_id):
    card_path = get_card_path(card_id)
    
    # 生成缩略图（路由到对应的渲染器）
    thumbnail = core.route({
        'action': 'generateThumbnail',
        'params': {'cardPath': card_path}
    })
    
    return thumbnail.data
```

**验收标准**：
- ✅ 支持嵌入式模式（作为库使用）
- ✅ 提供多语言API
- ✅ 不干扰宿主系统
- ✅ 资源占用可控

## 故事地图总结

```
开发者旅程：
1. 快速开始 (US-001) →
2. 学习模块通信 (US-002) →
3. 声明依赖关系 (US-003) →
4. 使用事件系统 (US-004) →
5. 使用配置管理 (US-005) →
6. 开发复杂功能 (US-006)

应用开发旅程：
7. 开发完整应用 (US-007) →
8. 调试和监控 (US-008)

发布旅程：
9. 打包插件 (US-009) →
10. 更新插件 (US-010) →
11. 制作独立软件 (US-011) →
12. 共享内核模式 (US-012)

集成旅程：
13. CLI脚本 (US-013) →
14. 系统集成 (US-014)
```

每个用户故事都体现了内核的核心价值：**简化复杂度、统一标准、灵活扩展**。

---

**文档维护者**：Chips 生态核心团队  
**最后更新**：2026-01-31  
**状态**：✅ 生效
