# Chips生态通用开发规范

**版本**: 1.0.0  
**最后更新**: 2026-01-30  
**适用范围**: 所有Chips生态项目

---

## 1. 架构规范

### 1.1 中心路由原则 ⭐ 最重要

**强制要求**:
- ✅ 所有模块间通信**必须**通过薯片内核路由
- ❌ **禁止**模块之间直接调用或通信
- ✅ 所有外部输入**必须**经过内核统一入口

**实现要求**:
```rust
// ✅ 正确：通过内核路由
kernel.request("target_module", "method", params).await?;

// ❌ 错误：直接调用
target_module.method(params); // 禁止！
```

**违规检查**:
- 代码审查必须检查是否有直接模块调用
- CI/CD中集成静态分析工具检测跨模块引用

### 1.2 模块化设计

**要求**:
- 每个功能模块必须独立可替换
- 模块只通过标准接口对外暴露
- 模块内部实现对外部完全透明

**模块注册**:
```rust
// 模块必须通过内核注册
kernel.register_module(ModuleDescriptor {
    id: "my-module",
    version: "1.0.0",
    interfaces: vec![/* 接口列表 */],
    dependencies: vec![/* 依赖列表 */],
});
```

### 1.3 前后端分离

**强制要求**:
- ✅ 前端只负责UI展示和交互
- ✅ 后端只负责业务逻辑和数据处理
- ❌ 前端**禁止**包含业务逻辑代码
- ❌ 后端**禁止**包含UI代码

**通信方式**:
- 前后端通过内核路由通信
- 使用标准化的请求/响应格式
- 遵循前端接口标准和后端接口标准

---

## 2. 多语言规范 ⭐ 核心规范

### 2.1 零硬编码原则

**绝对禁止**:
```typescript
// ❌ 禁止：硬编码文本
<button>确定</button>
alert("保存成功");
console.log("加载完成");

// ❌ 禁止：硬编码消息
throw new Error("文件未找到");
```

**正确做法**:
```typescript
// ✅ 正确：使用多语言系统
<button>{t('i18n.core.000001')}</button>
alert(t('i18n.ui.100050'));
console.log(t('i18n.log.001'));

// ✅ 正确：错误消息也使用编码
throw new Error(t('i18n.error.010001'));
```

### 2.2 开发阶段使用

**开发时使用key**:
```typescript
// 开发阶段使用可读的key
<button>{t('common.ok')}</button>
<p>{t('ui.loading')}</p>
```

**打包时自动替换**:
```bash
# 构建工具自动替换
npm run build
# common.ok → i18n.core.000001
# ui.loading → i18n.ui.100001
```

### 2.3 配置表管理

**所有文本必须在配置表中**:
```yaml
# i18n.yaml
vocabulary:
  common:
    ok: "i18n.core.000001"
    cancel: "i18n.core.000002"
    
  messages:
    save_success: "i18n.core.011001"
    file_not_found: "i18n.core.010001"
```

**强制检查**:
- CI/CD中检查是否有硬编码字符串
- 代码审查必须验证所有文本都使用t()函数

---

## 3. 代码规范

### 3.1 命名规范

**通用规范**:
- 类名：PascalCase（大驼峰）
- 函数/方法：camelCase（小驼峰）
- 常量：UPPER_SNAKE_CASE
- 变量：camelCase
- 文件名：kebab-case（短横线）

**示例**:
```typescript
// ✅ 正确
class UserManager { }
function getUserInfo() { }
const MAX_RETRY_COUNT = 3;
let userName = "张三";
// 文件名: user-manager.ts

// ❌ 错误
class user_manager { }
function GetUserInfo() { }
const maxRetryCount = 3;
let UserName = "张三";
```

### 3.2 注释规范

**必须注释的内容**:
- 所有公共API的文档注释
- 复杂算法的实现说明
- 非显而易见的代码逻辑
- TODO/FIXME标记

**注释格式**:
```typescript
/**
 * 获取用户信息
 * @param userId 用户ID（10位62进制）
 * @returns 用户信息对象
 * @throws {UserNotFoundError} 用户不存在时抛出
 */
async function getUserInfo(userId: string): Promise<User> {
  // 实现代码
}
```

**注释多语言**:
- 文档注释使用中文
- 代码内联注释使用中文
- API文档同时提供中英文

### 3.3 错误处理

**统一错误码**:
```typescript
// 使用标准错误码
enum ErrorCode {
  FILE_NOT_FOUND = 'E_FILE_001',
  NETWORK_ERROR = 'E_NET_001',
  PERMISSION_DENIED = 'E_PERM_001',
}

// 抛出错误时使用错误码
throw new ChipsError(
  ErrorCode.FILE_NOT_FOUND,
  t('i18n.error.010001')
);
```

**错误处理要求**:
- 所有异步操作必须处理错误
- 不允许空catch块
- 关键操作必须记录日志

```typescript
// ✅ 正确
try {
  await doSomething();
} catch (error) {
  logger.error('操作失败', { error, context });
  throw new ChipsError(ErrorCode.OPERATION_FAILED, error);
}

// ❌ 错误
try {
  await doSomething();
} catch (error) {
  // 空catch - 禁止！
}
```

---

## 4. 接口规范

### 4.1 API设计

**RESTful API规范**:
```
GET    /api/cards          # 获取列表
POST   /api/cards          # 创建
GET    /api/cards/:id      # 获取单个
PUT    /api/cards/:id      # 更新
DELETE /api/cards/:id      # 删除
```

**响应格式**:
```typescript
// 成功响应
{
  "code": 0,
  "message": "success",
  "data": { /* 实际数据 */ }
}

// 错误响应
{
  "code": "E_FILE_001",
  "message": "文件未找到",
  "details": { /* 错误详情 */ }
}
```

### 4.2 接口版本管理

**版本标注**:
```typescript
/**
 * @since 1.0.0
 * @deprecated 2.0.0 使用 newMethod 替代
 */
function oldMethod() { }
```

**废弃处理**:
- 标记为废弃但保留至少一个大版本
- 提供迁移指南
- 在日志中警告使用废弃API

---

## 5. 测试规范

### 5.1 测试覆盖率

**强制要求**:
- 核心模块：≥90%
- 业务模块：≥80%
- UI组件：≥70%
- 工具函数：≥95%

**测试类型**:
- 单元测试：必须覆盖所有公共函数
- 集成测试：覆盖核心业务流程
- E2E测试：覆盖关键用户路径

### 5.2 测试命名

**格式**: `describe_what_when_then`

```typescript
describe('UserManager', () => {
  describe('getUserInfo', () => {
    it('should return user when user exists', async () => {
      // 测试代码
    });
    
    it('should throw error when user not found', async () => {
      // 测试代码
    });
  });
});
```

### 5.3 Mock和Stub

**原则**:
- 外部依赖必须Mock
- 内核调用必须Mock
- 时间依赖必须可控

```typescript
// ✅ 正确：Mock内核调用
jest.mock('@chips/kernel');
mockKernel.request.mockResolvedValue(mockData);
```

---

## 6. 性能规范

### 6.1 性能指标

**强制要求**:
- 内核路由延迟：<10ms (P95)
- 模块加载时间：<100ms
- UI响应时间：<100ms
- API响应时间：<200ms (P95)

### 6.2 优化要求

**必须实现**:
- 按需加载：模块和资源懒加载
- 缓存策略：合理使用内存和磁盘缓存
- 防抖节流：高频操作必须防抖
- 虚拟滚动：长列表必须虚拟化

**示例**:
```typescript
// ✅ 防抖
const debouncedSave = debounce(save, 500);

// ✅ 虚拟滚动
<VirtualList items={items} itemHeight={50} />

// ✅ 懒加载
const Module = lazy(() => import('./Module'));
```

---

## 7. 安全规范

### 7.1 输入验证

**强制要求**:
- 所有用户输入必须验证
- 所有外部数据必须清洗
- 使用白名单而非黑名单

```typescript
// ✅ 正确：验证输入
function setUserName(name: string) {
  if (!isValidUserName(name)) {
    throw new ValidationError('无效的用户名');
  }
  // 处理
}
```

### 7.2 XSS防护

**要求**:
- 所有用户输入的HTML必须转义
- 使用安全的DOM操作方法
- CSP策略配置

```typescript
// ✅ 正确：转义HTML
const safeHtml = escapeHtml(userInput);

// ❌ 错误：直接插入
element.innerHTML = userInput; // 禁止！
```

### 7.3 认证和权限

**要求**:
- API调用必须验证权限
- 敏感操作必须二次确认
- 密钥和令牌不得硬编码

---

## 8. 日志规范

### 8.1 日志级别

**使用标准**:
- ERROR：错误和异常
- WARN：警告信息
- INFO：重要事件
- DEBUG：调试信息（生产关闭）

### 8.2 日志格式

**标准格式**:
```typescript
logger.info('用户登录成功', {
  userId: user.id,
  ip: request.ip,
  timestamp: Date.now(),
});
```

**不允许**:
```typescript
// ❌ 不使用console.log
console.log('用户登录'); // 禁止！

// ✅ 使用日志系统
logger.info('用户登录成功', { userId });
```

---

## 9. Git规范

### 9.1 分支管理

**分支类型**:
- `main`: 主分支，生产代码
- `develop`: 开发分支
- `feature/*`: 功能分支
- `fix/*`: 修复分支
- `release/*`: 发布分支

### 9.2 提交规范

**Commit格式**:
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type类型**:
- feat: 新功能
- fix: 修复bug
- docs: 文档更新
- style: 代码格式
- refactor: 重构
- test: 测试相关
- chore: 构建/工具

**示例**:
```
feat(editor): 添加无限画布缩放功能

- 实现缩放手势支持
- 添加缩放比例显示
- 优化缩放性能

Closes #123
```

---

## 10. 文档规范

### 10.1 代码文档

**必须包含**:
- README.md：项目说明
- API文档：所有公开API
- CHANGELOG.md：变更日志
- 贡献指南

### 10.2 文档更新

**要求**:
- API变更必须同步更新文档
- 新功能必须有使用说明
- 废弃功能必须有迁移指南

---

## 11. 依赖管理

### 11.1 依赖选择

**原则**:
- 优先使用生态内的依赖
- 外部依赖必须评估
- 避免重复依赖

**评估标准**:
- 维护活跃度
- 许可证兼容性
- 安全性记录
- 社区支持

### 11.2 版本锁定

**要求**:
- 使用锁文件（package-lock.json/Cargo.lock）
- 定期更新依赖
- 及时修复安全漏洞

---

## 12. CI/CD规范

### 12.1 持续集成

**必须包含**:
- 代码检查（Lint）
- 单元测试
- 集成测试
- 构建验证

**流程**:
```yaml
# .github/workflows/ci.yml
on: [push, pull_request]
jobs:
  test:
    - run: npm run lint
    - run: npm run test
    - run: npm run build
```

### 12.2 持续部署

**要求**:
- 自动化部署流程
- 灰度发布支持
- 回滚机制

---

## 13. 代码审查

### 13.1 审查要点

**必须检查**:
- [ ] 是否遵循中心路由原则
- [ ] 是否有硬编码文本
- [ ] 是否有适当的错误处理
- [ ] 是否有足够的测试覆盖
- [ ] 是否有文档更新
- [ ] 是否符合性能要求

### 13.2 审查流程

**要求**:
- 所有PR必须经过代码审查
- 至少一人approval才能合并
- 关键模块需要专家审查

---

## 14. 开源合规

### 14.1 许可证

**要求**:
- 明确标注使用的开源库
- 遵守开源许可证要求
- 贡献代码必须有CLA

### 14.2 开源组件

**使用原则**:
- 优先使用MIT/Apache 2.0许可证
- 避免使用GPL许可证（传染性）
- 记录所有开源依赖

**文档要求**:
```markdown
# 第三方依赖

- React (MIT License)
- Video.js (Apache 2.0)
- ...
```

---

## 15. 开发环境

### 15.1 环境配置

**标准化**:
- 使用.env文件管理环境变量
- 提供开发环境配置模板
- 不提交敏感配置

```bash
# .env.example
DATABASE_URL=postgres://localhost/chips
API_KEY=your_api_key_here
```

### 15.2 开发工具

**推荐工具**:
- IDE: VSCode/Cursor
- 格式化: Prettier/rustfmt
- Lint: ESLint/clippy
- Git Hook: Husky

---

## 16. 违规处理

### 16.1 严重违规

**以下行为禁止合并代码**:
- 违反中心路由原则
- 包含硬编码文本
- 没有错误处理的关键操作
- 测试覆盖率不达标

### 16.2 警告处理

**以下行为需要修改**:
- 命名不规范
- 注释缺失
- 日志不完整
- 性能问题

---

## 17. 开发流程

### 17.1 功能开发

**标准流程**:
1. 创建功能分支
2. 编写代码和测试
3. 自测通过
4. 提交PR
5. 代码审查
6. 修改问题
7. 合并到develop

### 17.2 Bug修复

**标准流程**:
1. 创建修复分支
2. 编写测试重现bug
3. 修复代码
4. 测试验证
5. 提交PR
6. 快速审查
7. 合并到main

---

## 18. 附录

### 18.1 相关文档

- [薯片协议规范](../生态共用/01-薯片协议规范.md)
- [多语言系统规范](../生态共用/11-多语言系统规范.md)
- [前端接口标准](../生态共用/05-前端接口标准.md)
- [后端接口标准](../生态共用/06-后端接口标准.md)
- [插件开发规范](../生态共用/07-插件开发规范.md)

### 18.2 检查清单

**代码提交前检查**:
- [ ] 无硬编码文本
- [ ] 遵循中心路由
- [ ] 错误处理完整
- [ ] 测试覆盖率达标
- [ ] 代码格式化
- [ ] 文档已更新
- [ ] Commit信息规范

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-30  
**状态**: ✅ 生效

---

## 薯片内核特定开发规范

### 1. Rust编程规范

#### 1.1 所有权和生命周期 ⭐ 关键

**强制要求**:
- ✅ 优先使用所有权转移，避免不必要的克隆
- ✅ 合理使用引用（&T）和可变引用（&mut T）
- ❌ **禁止**滥用`clone()`，除非确实需要
- ✅ 生命周期标注必须清晰明确

```rust
// ✅ 正确：使用引用避免所有权转移
pub fn process_request(request: &RouteRequest) -> Result<()> {
    // 处理请求，不需要获取所有权
}

// ❌ 错误：不必要的所有权转移
pub fn process_request(request: RouteRequest) -> Result<()> {
    // 如果不需要所有权，不要这样写
}

// ✅ 正确：明确的生命周期标注
pub struct RequestHandler<'a> {
    router: &'a Router,
    timeout: Duration,
}

// ✅ 正确：使用Arc共享所有权（多线程场景）
let router = Arc::new(Router::new());
let handler = RequestHandler {
    router: Arc::clone(&router),
};
```

**数据共享策略**:
```rust
// 单线程：使用Rc<T>
use std::rc::Rc;
let data = Rc::new(expensive_data);

// 多线程：使用Arc<T>
use std::sync::Arc;
let data = Arc::new(expensive_data);

// 内部可变性（单线程）：RefCell<T>
use std::cell::RefCell;
let data = Rc::new(RefCell::new(mutable_data));

// 内部可变性（多线程）：Mutex<T> 或 RwLock<T>
use std::sync::{Mutex, RwLock};
let data = Arc::new(Mutex::new(mutable_data));
let shared = Arc::new(RwLock::new(read_heavy_data));
```

#### 1.2 异步编程规范 ⭐ 关键

**Tokio运行时要求**:
- ✅ 使用`tokio::spawn`创建异步任务
- ✅ I/O操作使用`tokio::fs`、`tokio::net`等
- ✅ 正确处理异步函数的错误
- ❌ **禁止**在async函数中阻塞线程

```rust
// ✅ 正确：异步文件读取
async fn read_file(path: &Path) -> Result<Vec<u8>> {
    tokio::fs::read(path).await.map_err(Into::into)
}

// ❌ 错误：在async函数中使用同步I/O
async fn read_file_bad(path: &Path) -> Result<Vec<u8>> {
    std::fs::read(path).map_err(Into::into) // 阻塞！
}

// ✅ 正确：并发处理多个请求
async fn process_batch(requests: Vec<Request>) -> Vec<Result<Response>> {
    let tasks: Vec<_> = requests
        .into_iter()
        .map(|req| tokio::spawn(process_request(req)))
        .collect();
    
    let results = futures::future::join_all(tasks).await;
    results.into_iter().map(|r| r.unwrap()).collect()
}

// ✅ 正确：超时控制
async fn request_with_timeout(req: Request) -> Result<Response> {
    tokio::time::timeout(
        Duration::from_secs(30),
        process_request(req)
    )
    .await
    .map_err(|_| Error::Timeout)?
}

// ✅ 正确：select! 处理多个Future
use tokio::select;

async fn handle_request_or_shutdown(req: Request, shutdown: Receiver<()>) -> Result<()> {
    select! {
        result = process_request(req) => {
            result?;
        }
        _ = shutdown.recv() => {
            info!("Shutdown signal received");
            return Ok(());
        }
    }
    Ok(())
}
```

**异步锁的使用**:
```rust
// ✅ 正确：使用tokio的异步锁
use tokio::sync::{Mutex, RwLock};

pub struct RouteTable {
    routes: Arc<RwLock<HashMap<String, RouteEntry>>>,
}

impl RouteTable {
    pub async fn find_route(&self, action: &str) -> Option<RouteEntry> {
        let routes = self.routes.read().await;
        routes.get(action).cloned()
    }
    
    pub async fn register_route(&self, action: String, entry: RouteEntry) -> Result<()> {
        let mut routes = self.routes.write().await;
        routes.insert(action, entry);
        Ok(())
    }
}

// ❌ 错误：在异步上下文使用标准库的锁
use std::sync::Mutex; // 不要在async中使用！
```

#### 1.3 错误处理规范 ⭐ 关键

**Result类型强制使用**:
- ✅ 所有可能失败的函数返回`Result<T, E>`
- ✅ 使用`?`操作符传播错误
- ✅ 自定义错误类型实现`std::error::Error`
- ❌ **禁止**使用`unwrap()`和`expect()`（除测试代码外）

```rust
// ✅ 正确：定义错误类型
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CoreError {
    #[error("Module not found: {0}")]
    ModuleNotFound(String),
    
    #[error("Route not found for action: {0}")]
    RouteNotFound(String),
    
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
}

pub type Result<T> = std::result::Result<T, CoreError>;

// ✅ 正确：错误处理
async fn load_module(module_id: &str) -> Result<Module> {
    let path = find_module_path(module_id)?;
    let content = tokio::fs::read(&path).await?;
    let metadata: ModuleMetadata = serde_json::from_slice(&content)?;
    
    Ok(Module::new(metadata))
}

// ❌ 错误：使用unwrap
async fn load_module_bad(module_id: &str) -> Module {
    let path = find_module_path(module_id).unwrap(); // 禁止！
    let content = tokio::fs::read(&path).await.unwrap(); // 禁止！
    let metadata = serde_json::from_slice(&content).unwrap(); // 禁止！
    Module::new(metadata)
}

// ✅ 正确：在测试中可以使用unwrap
#[cfg(test)]
mod tests {
    #[tokio::test]
    async fn test_load_module() {
        let module = load_module("test-module").await.unwrap();
        assert_eq!(module.id, "test-module");
    }
}
```

**错误上下文**:
```rust
use anyhow::{Context, Result};

async fn load_config(path: &Path) -> Result<Config> {
    let content = tokio::fs::read_to_string(path)
        .await
        .context(format!("Failed to read config file: {}", path.display()))?;
    
    let config: Config = serde_yaml::from_str(&content)
        .context("Failed to parse config file")?;
    
    Ok(config)
}
```

#### 1.4 线程安全规范

**Send和Sync要求**:
```rust
// ✅ 正确：确保跨线程安全
pub struct Router {
    route_table: Arc<RwLock<RouteTable>>,
    // Arc<RwLock<T>> 实现了 Send + Sync
}

// 编译时检查
fn assert_send_sync<T: Send + Sync>() {}
assert_send_sync::<Router>();

// ✅ 正确：使用channel进行线程间通信
use tokio::sync::mpsc;

async fn worker_loop(mut rx: mpsc::Receiver<Request>) {
    while let Some(request) = rx.recv().await {
        process_request(request).await;
    }
}

// ✅ 正确：使用oneshot for request-response
use tokio::sync::oneshot;

async fn send_request(tx: oneshot::Sender<Response>, req: Request) {
    let response = process_request(req).await;
    let _ = tx.send(response);
}
```

#### 1.5 性能优化原则

**零拷贝和内存效率**:
```rust
// ✅ 正确：使用Cow避免不必要的分配
use std::borrow::Cow;

fn process_path(path: &str) -> Cow<str> {
    if path.starts_with('/') {
        Cow::Borrowed(path)
    } else {
        Cow::Owned(format!("/{}", path))
    }
}

// ✅ 正确：使用迭代器避免中间分配
let total: u64 = items
    .iter()
    .filter(|item| item.is_valid())
    .map(|item| item.size)
    .sum();

// ✅ 正确：预分配容量
let mut vec = Vec::with_capacity(expected_size);

// ✅ 正确：使用引用避免克隆
fn find_route<'a>(routes: &'a [Route], action: &str) -> Option<&'a Route> {
    routes.iter().find(|r| r.action == action)
}
```

### 2. 中心路由实现规范

#### 2.1 路由表设计规范 ⭐ 最重要

**路由表操作要求**:
- ✅ 路由表使用`RwLock`保护，读多写少
- ✅ 查找操作必须高效（O(1)或O(log n)）
- ✅ 支持动态更新路由规则
- ✅ 路由优先级明确

```rust
// ✅ 正确的路由表实现
pub struct RouteTable {
    // 按action索引的路由
    action_routes: HashMap<String, Vec<RouteEntry>>,
    // 按资源类型索引的路由
    resource_routes: HashMap<String, Vec<RouteEntry>>,
    // 自定义路由规则
    custom_routes: Vec<CustomRouteEntry>,
    // 读写锁保护
    lock: RwLock<()>,
}

impl RouteTable {
    // 查找路由（只读锁）
    pub async fn find_route(&self, request: &RouteRequest) -> Option<RouteEntry> {
        let _guard = self.lock.read().await;
        
        // 1. 检查自定义路由（最高优先级）
        for custom in &self.custom_routes {
            if custom.pattern.is_match(&request.action) {
                return Some(custom.entry.clone());
            }
        }
        
        // 2. 按action查找
        if let Some(entries) = self.action_routes.get(&request.action) {
            return self.find_best_entry(entries);
        }
        
        // 3. 按资源类型查找
        if let Some(ref resource_type) = request.resource_type {
            if let Some(entries) = self.resource_routes.get(resource_type) {
                return self.find_best_entry(entries);
            }
        }
        
        None
    }
    
    // 注册路由（写锁）
    pub async fn register_route(&self, action: String, entry: RouteEntry) -> Result<()> {
        let _guard = self.lock.write().await;
        
        self.action_routes
            .entry(action)
            .or_insert_with(Vec::new)
            .push(entry);
        
        Ok(())
    }
}
```

#### 2.2 请求处理规范

**请求处理流程**:
```rust
impl Router {
    pub async fn route(&self, request: RouteRequest) -> RouteResponse {
        let start = Instant::now();
        
        // 1. 验证请求（必须）
        if let Err(e) = self.validate_request(&request) {
            return RouteResponse::error(
                &request.request_id,
                StatusCode::BAD_REQUEST,
                ErrorInfo::from(e),
                start.elapsed().as_millis() as u64,
            );
        }
        
        // 2. 检查权限（必须）
        if let Err(e) = self.check_permission(&request) {
            return RouteResponse::error(
                &request.request_id,
                StatusCode::FORBIDDEN,
                ErrorInfo::from(e),
                start.elapsed().as_millis() as u64,
            );
        }
        
        // 3. 查找目标模块（必须）
        let target = match self.find_target(&request) {
            Ok(t) => t,
            Err(e) => {
                return RouteResponse::error(
                    &request.request_id,
                    StatusCode::NOT_FOUND,
                    ErrorInfo::from(e),
                    start.elapsed().as_millis() as u64,
                );
            }
        };
        
        // 4. 记录日志（必须）
        self.log_request(&request, &target);
        
        // 5. 转发请求（核心）
        let response = self.forward_request(&request, &target).await;
        
        // 6. 记录响应日志（必须）
        self.log_response(&response);
        
        response
    }
}
```

#### 2.3 并发控制规范 ⭐ 性能关键

**工作线程池设计**:
```rust
// ✅ 正确：使用tokio的并发控制
use tokio::sync::Semaphore;

pub struct Router {
    // 限制并发数
    concurrency_limit: Arc<Semaphore>,
    // 请求队列
    request_queue: Arc<RequestQueue>,
}

impl Router {
    pub async fn route(&self, request: RouteRequest) -> RouteResponse {
        // 获取并发许可
        let _permit = self.concurrency_limit.acquire().await.unwrap();
        
        // 处理请求
        self.process_request(request).await
    }
    
    // 启动工作线程池
    pub fn start_workers(&self, worker_count: usize) {
        for i in 0..worker_count {
            let queue = Arc::clone(&self.request_queue);
            let router = self.clone();
            
            tokio::spawn(async move {
                loop {
                    if let Some(item) = queue.dequeue().await {
                        let response = router.process_request(item.request).await;
                        let _ = item.response_tx.send(response);
                    }
                }
            });
        }
    }
}
```

**性能要求监控**:
```rust
// ✅ 正确：性能指标收集
pub struct RouteMetrics {
    total_requests: AtomicU64,
    successful_requests: AtomicU64,
    failed_requests: AtomicU64,
    total_latency_ms: AtomicU64,
}

impl Router {
    async fn route(&self, request: RouteRequest) -> RouteResponse {
        let start = Instant::now();
        
        // 处理请求
        let response = self.process_request(request).await;
        
        // 记录指标
        let latency = start.elapsed().as_millis() as u64;
        self.metrics.total_requests.fetch_add(1, Ordering::Relaxed);
        self.metrics.total_latency_ms.fetch_add(latency, Ordering::Relaxed);
        
        if latency > 10 {
            warn!("Route latency exceeded 10ms: {}ms", latency);
        }
        
        if response.status == StatusCode::OK {
            self.metrics.successful_requests.fetch_add(1, Ordering::Relaxed);
        } else {
            self.metrics.failed_requests.fetch_add(1, Ordering::Relaxed);
        }
        
        response
    }
}
```

### 3. 模块管理规范

#### 3.1 模块注册规范

**模块元数据验证**:
```rust
// ✅ 正确：严格的元数据验证
impl ModuleRegistry {
    pub async fn register(&self, module_path: &Path) -> Result<String> {
        // 1. 读取module.yaml
        let metadata = self.load_metadata(module_path).await?;
        
        // 2. 验证必需字段
        self.validate_metadata(&metadata)?;
        
        // 3. 检查ID冲突
        if self.exists(&metadata.id).await {
            return Err(Error::ModuleAlreadyExists(metadata.id.clone()));
        }
        
        // 4. 验证版本号
        Version::parse(&metadata.version)
            .map_err(|e| Error::InvalidVersion(e.to_string()))?;
        
        // 5. 验证依赖
        self.validate_dependencies(&metadata.dependencies).await?;
        
        // 6. 注册到注册表
        let module_info = ModuleInfo {
            metadata,
            path: module_path.to_path_buf(),
            registered_at: Utc::now(),
            last_loaded_at: None,
            load_count: 0,
        };
        
        let mut modules = self.modules.write().await;
        modules.insert(module_info.metadata.id.clone(), module_info);
        
        Ok(module_info.metadata.id.clone())
    }
}
```

#### 3.2 依赖解析规范 ⭐ 关键

**依赖关系检查**:
```rust
// ✅ 正确：完整的依赖解析
impl DependencyResolver {
    pub async fn resolve(&self, module_id: &str) -> Result<Vec<String>> {
        let mut resolved = Vec::new();
        let mut visited = HashSet::new();
        
        // 递归解析依赖
        self.resolve_recursive(module_id, &mut resolved, &mut visited).await?;
        
        // 拓扑排序确定加载顺序
        let load_order = self.topological_sort(&resolved)?;
        
        Ok(load_order)
    }
    
    async fn resolve_recursive(
        &self,
        module_id: &str,
        resolved: &mut Vec<String>,
        visited: &mut HashSet<String>,
    ) -> Result<()> {
        // 检测循环依赖
        if visited.contains(module_id) {
            if !resolved.contains(&module_id.to_string()) {
                return Err(Error::CircularDependency(module_id.to_string()));
            }
            return Ok(());
        }
        
        visited.insert(module_id.to_string());
        
        // 获取模块信息
        let module = self.registry.get_module(module_id).await
            .ok_or_else(|| Error::ModuleNotFound(module_id.to_string()))?;
        
        // 解析每个依赖
        for dep in &module.metadata.dependencies {
            // 检查依赖是否存在
            let dep_module = self.registry.get_module(&dep.id).await
                .ok_or_else(|| Error::DependencyNotFound(dep.id.clone()))?;
            
            // 检查版本兼容性
            if !dep.version.matches(&dep_module.metadata.version) {
                return Err(Error::VersionMismatch {
                    module: dep.id.clone(),
                    required: dep.version.to_string(),
                    found: dep_module.metadata.version.to_string(),
                });
            }
            
            // 递归解析依赖的依赖
            self.resolve_recursive(&dep.id, resolved, visited).await?;
        }
        
        // 加入已解析列表
        if !resolved.contains(&module_id.to_string()) {
            resolved.push(module_id.to_string());
        }
        
        Ok(())
    }
}
```

#### 3.3 热插拔实现规范

**安全的模块卸载**:
```rust
// ✅ 正确：安全的卸载流程
impl ModuleLoader {
    pub async fn unload(&self, module_id: &str) -> Result<()> {
        // 1. 检查依赖关系
        let dependents = self.get_dependents(module_id).await;
        if !dependents.is_empty() {
            return Err(Error::ModuleHasDependents {
                module: module_id.to_string(),
                dependents,
            });
        }
        
        // 2. 调用模块的cleanup钩子
        if let Some(instance) = self.instances.get(module_id) {
            instance.cleanup().await?;
        }
        
        // 3. 移除路由规则
        self.router.remove_module_routes(module_id).await?;
        
        // 4. 取消事件订阅
        self.event_bus.unsubscribe_all(module_id).await?;
        
        // 5. 释放资源
        self.instances.remove(module_id);
        
        // 6. 更新状态
        self.registry.set_state(module_id, ModuleState::Unloaded).await?;
        
        info!("Module unloaded successfully: {}", module_id);
        Ok(())
    }
}
```

### 4. 资源管理规范

#### 4.1 资源提供者实现规范

**标准提供者接口实现**:
```rust
// ✅ 正确：实现ResourceProvider trait
#[async_trait]
impl ResourceProvider for HttpProvider {
    async fn read(&self, resource: &ResolvedResource) -> Result<Vec<u8>> {
        let mut request = self.client.get(&resource.url);
        
        // 添加认证
        if let Some(auth) = self.auth_manager.get_auth(&resource.url).await? {
            request = self.apply_auth(request, auth);
        }
        
        // 设置超时
        request = request.timeout(Duration::from_secs(30));
        
        // 发送请求
        let response = request.send().await.map_err(Error::from)?;
        
        // 检查状态码
        if !response.status().is_success() {
            return Err(Error::HttpError {
                status: response.status().as_u16(),
                url: resource.url.clone(),
            });
        }
        
        // 读取数据
        let data = response.bytes().await.map_err(Error::from)?.to_vec();
        
        Ok(data)
    }
    
    async fn write(&self, resource: &ResolvedResource, data: &[u8]) -> Result<()> {
        // 类似实现
        todo!()
    }
    
    async fn exists(&self, resource: &ResolvedResource) -> Result<bool> {
        // HEAD请求检查
        let response = self.client.head(&resource.url).send().await?;
        Ok(response.status().is_success())
    }
}
```

#### 4.2 缓存策略规范

**LRU缓存实现**:
```rust
// ✅ 正确：高效的缓存实现
pub struct CacheManager {
    cache_dir: PathBuf,
    index: Arc<RwLock<HashMap<String, CacheEntry>>>,
    lru: Arc<Mutex<LruCache<String, ()>>>,
    max_size: u64,
    current_size: Arc<AtomicU64>,
}

impl CacheManager {
    pub async fn get(&self, url: &str) -> Option<Vec<u8>> {
        // 1. 检查索引
        let index = self.index.read().await;
        let entry = index.get(url)?;
        
        // 2. 检查是否过期
        if self.is_expired(entry) {
            drop(index);
            self.remove(url).await.ok()?;
            return None;
        }
        
        // 3. 读取缓存文件
        let data = tokio::fs::read(&entry.path).await.ok()?;
        
        // 4. 更新LRU
        let mut lru = self.lru.lock().await;
        lru.get(url);
        
        Some(data)
    }
    
    pub async fn put(&self, url: &str, data: &[u8]) -> Result<()> {
        let size = data.len() as u64;
        
        // 1. 确保有足够空间
        self.ensure_space(size).await?;
        
        // 2. 写入缓存文件
        let cache_key = Self::hash_url(url);
        let cache_path = self.cache_dir.join(&cache_key);
        tokio::fs::write(&cache_path, data).await?;
        
        // 3. 更新索引
        let entry = CacheEntry {
            path: cache_path,
            size,
            cached_at: Utc::now(),
            expires_at: None,
            etag: None,
        };
        
        let mut index = self.index.write().await;
        index.insert(url.to_string(), entry);
        
        // 4. 更新LRU和大小
        let mut lru = self.lru.lock().await;
        lru.put(url.to_string(), ());
        self.current_size.fetch_add(size, Ordering::Relaxed);
        
        Ok(())
    }
}
```

#### 4.3 认证处理规范

**安全的认证管理**:
```rust
// ✅ 正确：使用系统密钥链
use keyring::Entry;

pub struct AuthManager {
    service_name: String,
}

impl AuthManager {
    pub fn new() -> Self {
        Self {
            service_name: "chips-core".to_string(),
        }
    }
    
    pub async fn save_auth(&self, host: &str, auth: &Auth) -> Result<()> {
        let entry = Entry::new(&self.service_name, host)?;
        let serialized = serde_json::to_string(auth)?;
        entry.set_password(&serialized)?;
        
        info!("Auth saved for host: {}", host);
        Ok(())
    }
    
    pub async fn get_auth(&self, url: &str) -> Result<Option<Auth>> {
        let host = Self::extract_host(url)?;
        let entry = Entry::new(&self.service_name, &host)?;
        
        match entry.get_password() {
            Ok(password) => {
                let auth: Auth = serde_json::from_str(&password)?;
                Ok(Some(auth))
            }
            Err(keyring::Error::NoEntry) => Ok(None),
            Err(e) => Err(Error::from(e)),
        }
    }
    
    pub async fn delete_auth(&self, host: &str) -> Result<()> {
        let entry = Entry::new(&self.service_name, host)?;
        entry.delete_password()?;
        
        info!("Auth deleted for host: {}", host);
        Ok(())
    }
}
```

### 5. 性能关键规范 ⭐ 核心指标

#### 5.1 路由延迟要求

**强制性能指标**:
- ✅ P95延迟 < 10ms
- ✅ P99延迟 < 20ms  
- ✅ 平均延迟 < 5ms

```rust
// ✅ 正确：性能监控和告警
impl Router {
    async fn route(&self, request: RouteRequest) -> RouteResponse {
        let start = Instant::now();
        
        let response = self.process_request(request).await;
        
        let elapsed = start.elapsed().as_millis() as u64;
        
        // 记录指标
        self.metrics.record_latency(elapsed);
        
        // 性能告警
        if elapsed > 20 {
            error!(
                request_id = %request.request_id,
                latency_ms = elapsed,
                "Route latency exceeded 20ms (P99 threshold)"
            );
        } else if elapsed > 10 {
            warn!(
                request_id = %request.request_id,
                latency_ms = elapsed,
                "Route latency exceeded 10ms (P95 threshold)"
            );
        }
        
        response
    }
}
```

#### 5.2 内存占用限制

**内存管理要求**:
```rust
// ✅ 正确：监控内存占用
use sysinfo::{System, SystemExt};

pub struct MemoryMonitor {
    system: System,
    max_memory_mb: u64,
}

impl MemoryMonitor {
    pub fn check_memory(&mut self) -> Result<()> {
        self.system.refresh_memory();
        
        let used_memory = self.system.used_memory() / 1024 / 1024; // MB
        
        if used_memory > self.max_memory_mb {
            error!(
                used_mb = used_memory,
                max_mb = self.max_memory_mb,
                "Memory usage exceeded limit"
            );
            
            // 触发垃圾回收或卸载不常用模块
            self.trigger_cleanup().await?;
        }
        
        Ok(())
    }
}
```

#### 5.3 并发性能要求

**并发能力指标**:
```rust
// ✅ 正确：支持1000+并发请求
pub struct Router {
    // 使用信号量限制并发
    concurrency_limit: Arc<Semaphore>,
    // 请求队列
    request_queue: Arc<RequestQueue>,
}

impl Router {
    pub fn new(config: RouterConfig) -> Self {
        Self {
            concurrency_limit: Arc::new(Semaphore::new(config.max_concurrency)),
            request_queue: Arc::new(RequestQueue::new(config.queue_size)),
        }
    }
    
    pub async fn route(&self, request: RouteRequest) -> RouteResponse {
        // 获取并发许可（如果达到限制会等待）
        let _permit = self.concurrency_limit.acquire().await.unwrap();
        
        // 处理请求
        self.process_request(request).await
    }
}
```

### 6. 测试规范

#### 6.1 单元测试要求

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_route_request_success() {
        // Arrange
        let router = Router::new(test_config());
        let request = RouteRequest {
            request_id: "test-123".to_string(),
            sender: "test-module".to_string(),
            action: "test.action".to_string(),
            payload: json!({"key": "value"}),
            ..Default::default()
        };
        
        // Act
        let response = router.route(request).await;
        
        // Assert
        assert_eq!(response.status, StatusCode::OK);
        assert!(response.elapsed_ms < 10); // 性能断言
    }
    
    #[tokio::test]
    async fn test_route_not_found() {
        let router = Router::new(test_config());
        let request = RouteRequest {
            action: "non.existent.action".to_string(),
            ..Default::default()
        };
        
        let response = router.route(request).await;
        
        assert_eq!(response.status, StatusCode::NOT_FOUND);
        assert!(response.error.is_some());
    }
}
```

#### 6.2 集成测试要求

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_full_module_lifecycle() {
        // 1. 创建内核
        let core = ChipsCore::new(test_config()).await.unwrap();
        
        // 2. 注册模块
        let module_id = core.register_module("test-module", test_module_path())
            .await
            .unwrap();
        
        // 3. 加载模块
        core.load_module(&module_id).await.unwrap();
        
        // 4. 发送请求
        let response = core.route(test_request()).await;
        assert_eq!(response.status, StatusCode::OK);
        
        // 5. 卸载模块
        core.unload_module(&module_id).await.unwrap();
        
        // 6. 验证模块已卸载
        assert!(!core.is_module_loaded(&module_id).await);
    }
}
```

#### 6.3 性能测试要求

```rust
#[cfg(test)]
mod bench_tests {
    use criterion::{black_box, criterion_group, criterion_main, Criterion};
    
    fn bench_route_latency(c: &mut Criterion) {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        let router = runtime.block_on(async {
            Router::new(test_config())
        });
        
        c.bench_function("route_latency", |b| {
            b.to_async(&runtime).iter(|| async {
                let request = black_box(test_request());
                router.route(request).await
            });
        });
    }
    
    criterion_group!(benches, bench_route_latency);
    criterion_main!(benches);
}
```

### 7. 日志和调试规范

#### 7.1 结构化日志

```rust
use tracing::{info, warn, error, debug};

// ✅ 正确：使用结构化日志
impl Router {
    async fn route(&self, request: RouteRequest) -> RouteResponse {
        debug!(
            request_id = %request.request_id,
            sender = %request.sender,
            action = %request.action,
            "Routing request"
        );
        
        let response = self.process_request(request).await;
        
        if response.status == StatusCode::OK {
            info!(
                request_id = %response.request_id,
                elapsed_ms = response.elapsed_ms,
                "Request completed successfully"
            );
        } else {
            error!(
                request_id = %response.request_id,
                status = response.status,
                error = ?response.error,
                "Request failed"
            );
        }
        
        response
    }
}
```

#### 7.2 调试信息

```rust
// ✅ 正确：提供详细的调试信息
impl Router {
    #[cfg(debug_assertions)]
    pub fn dump_route_table(&self) -> String {
        let table = self.route_table.read().unwrap();
        serde_json::to_string_pretty(&table).unwrap()
    }
    
    #[cfg(debug_assertions)]
    pub fn dump_metrics(&self) -> String {
        format!(
            "Total requests: {}\n\
             Successful: {}\n\
             Failed: {}\n\
             Avg latency: {:.2}ms\n\
             P95 latency: {:.2}ms\n\
             P99 latency: {:.2}ms",
            self.metrics.total_requests(),
            self.metrics.successful_requests(),
            self.metrics.failed_requests(),
            self.metrics.avg_latency_ms(),
            self.metrics.p95_latency_ms(),
            self.metrics.p99_latency_ms(),
        )
    }
}
```

### 8. 配置管理规范

```rust
use config::{Config, ConfigError, File};

// ✅ 正确：层级配置加载
#[derive(Debug, Deserialize)]
pub struct CoreConfig {
    pub router: RouterConfig,
    pub module_manager: ModuleManagerConfig,
    pub resource_manager: ResourceManagerConfig,
    pub log_level: String,
}

impl CoreConfig {
    pub fn load() -> Result<Self, ConfigError> {
        let config = Config::builder()
            // 默认配置
            .add_source(File::with_name("config/default"))
            // 环境特定配置
            .add_source(
                File::with_name(&format!("config/{}", std::env::var("ENV").unwrap_or_else(|_| "development".to_string())))
                    .required(false)
            )
            // 本地覆盖配置
            .add_source(File::with_name("config/local").required(false))
            // 环境变量覆盖
            .add_source(config::Environment::with_prefix("CHIPS"))
            .build()?;
        
        config.try_deserialize()
    }
}
```

---

## 检查清单

开发和审查时必须检查：

### 架构规范
- [ ] 所有模块通信通过内核路由
- [ ] 没有模块直接调用其他模块
- [ ] 遵循微内核架构原则

### Rust规范
- [ ] 正确使用所有权和生命周期
- [ ] 异步函数使用tokio运行时
- [ ] 所有可能失败的函数返回Result
- [ ] 没有使用unwrap()（测试代码除外）
- [ ] 正确使用Arc/RwLock处理并发

### 性能规范
- [ ] 路由延迟 < 10ms (P95)
- [ ] 内存占用在限制范围内
- [ ] 支持至少1000并发请求
- [ ] 使用缓存优化性能

### 测试规范
- [ ] 单元测试覆盖率 ≥90%
- [ ] 包含集成测试
- [ ] 包含性能基准测试
- [ ] 所有测试通过

### 日志规范
- [ ] 使用结构化日志
- [ ] 关键操作有日志记录
- [ ] 错误有详细的上下文
- [ ] 没有输出敏感信息

### 安全规范
- [ ] 输入验证完整
- [ ] 权限检查到位
- [ ] 认证信息安全存储
- [ ] 没有硬编码密钥

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-30  
**状态**: ✅ 生效
