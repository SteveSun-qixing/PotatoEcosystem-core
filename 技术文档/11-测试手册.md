# 11-测试手册

## 1. 测试策略

### 1.1 测试金字塔

```
       /\
      /E2E\          端到端测试 (5%)
     /------\
    /Integration\    集成测试 (15%)
   /------------\
  /Unit Tests    \   单元测试 (80%)
 /----------------\
```

### 1.2 测试类型

**单元测试（Unit Tests）**
- 测试单个函数、方法、类
- 覆盖率目标：80%+
- 执行速度：快速（毫秒级）
- 工具：Rust内置测试框架

**集成测试（Integration Tests）**
- 测试模块间协作
- 测试系统边界
- 执行速度：中等（秒级）
- 工具：Rust测试 + Mock

**性能测试（Performance Tests）**
- 基准测试关键路径
- 路由延迟 < 10ms
- 内存占用监控
- 工具：Criterion

**安全测试（Security Tests）**
- 权限验证
- 输入验证
- 沙箱隔离
- 工具：手动测试 + 安全扫描工具

## 2. 测试框架选择

### 2.1 单元测试框架

**Rust内置测试**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_function() {
        assert_eq!(2 + 2, 4);
    }
    
    #[test]
    #[should_panic]
    fn test_panic() {
        panic!("Expected panic");
    }
}
```

**运行测试**
```bash
# 运行所有测试
cargo test

# 运行特定测试
cargo test test_router

# 显示输出
cargo test -- --nocapture

# 并行度
cargo test -- --test-threads=4
```

### 2.2 性能测试框架

**Criterion**

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn route_benchmark(c: &mut Criterion) {
    c.bench_function("route_request", |b| {
        b.iter(|| {
            // 测试代码
            router.route(black_box(&request))
        });
    });
}

criterion_group!(benches, route_benchmark);
criterion_main!(benches);
```

**配置文件 Cargo.toml**
```toml
[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }

[[bench]]
name = "router_bench"
harness = false
```

### 2.3 Mock框架

**Mockall**

```rust
use mockall::*;

#[automock]
trait ResourceProvider {
    fn read(&self, path: &str) -> Result<Vec<u8>>;
}

#[test]
fn test_with_mock() {
    let mut mock = MockResourceProvider::new();
    mock.expect_read()
        .with(eq("test.txt"))
        .times(1)
        .returning(|_| Ok(vec![1, 2, 3]));
    
    // 使用mock
    let result = mock.read("test.txt");
    assert_eq!(result.unwrap(), vec![1, 2, 3]);
}
```

## 3. 测试用例设计

### 3.1 中心路由系统测试

**测试文件**: `tests/router_test.rs`

```rust
#[cfg(test)]
mod router_tests {
    use chips_core::router::*;
    
    // 基础路由测试
    #[tokio::test]
    async fn test_route_request() {
        let router = Router::new();
        
        let request = RouteRequest {
            action: "test.action".to_string(),
            params: HashMap::new(),
            ..Default::default()
        };
        
        let response = router.route(request).await;
        assert_eq!(response.status, 200);
    }
    
    // 路由查找测试
    #[test]
    fn test_find_route() {
        let mut route_table = RouteTable::new();
        
        route_table.register(
            "file.open",
            "editor-module",
            100
        );
        
        let request = RouteRequest {
            action: "file.open".to_string(),
            ..Default::default()
        };
        
        let route = route_table.find_route(&request);
        assert!(route.is_some());
        assert_eq!(route.unwrap().module_id, "editor-module");
    }
    
    // 超时测试
    #[tokio::test]
    async fn test_request_timeout() {
        let router = Router::new();
        
        let request = RouteRequest {
            action: "slow.action".to_string(),
            timeout_ms: 100,
            ..Default::default()
        };
        
        let response = router.route(request).await;
        assert_eq!(response.status, 408); // Timeout
    }
    
    // 并发测试
    #[tokio::test]
    async fn test_concurrent_requests() {
        let router = Arc::new(Router::new());
        let mut handles = vec![];
        
        for i in 0..100 {
            let router_clone = Arc::clone(&router);
            let handle = tokio::spawn(async move {
                let request = RouteRequest {
                    action: format!("action.{}", i),
                    ..Default::default()
                };
                router_clone.route(request).await
            });
            handles.push(handle);
        }
        
        for handle in handles {
            let response = handle.await.unwrap();
            assert!(response.status == 200 || response.status == 404);
        }
    }
    
    // 错误处理测试
    #[tokio::test]
    async fn test_invalid_request() {
        let router = Router::new();
        
        let request = RouteRequest {
            action: "".to_string(), // 空action
            ..Default::default()
        };
        
        let response = router.route(request).await;
        assert_eq!(response.status, 400); // Bad Request
    }
}
```

### 3.2 模块管理系统测试

**测试文件**: `tests/module_test.rs`

```rust
#[cfg(test)]
mod module_tests {
    use chips_core::module::*;
    
    // 模块加载测试
    #[tokio::test]
    async fn test_load_module() {
        let manager = ModuleManager::new(vec!["./test-modules".into()]);
        
        let result = manager.load("test-module").await;
        assert!(result.is_ok());
        
        let state = manager.get_state("test-module").await;
        assert_eq!(state, Some(ModuleState::Running));
    }
    
    // 依赖解析测试
    #[tokio::test]
    async fn test_dependency_resolution() {
        let resolver = DependencyResolver::new();
        
        // 模拟依赖: A -> B -> C
        let deps = resolver.resolve("module-a").await.unwrap();
        
        assert_eq!(deps, vec![
            "module-c".to_string(),
            "module-b".to_string(),
            "module-a".to_string(),
        ]);
    }
    
    // 循环依赖检测
    #[tokio::test]
    async fn test_circular_dependency() {
        let resolver = DependencyResolver::new();
        
        // 模拟循环依赖: A -> B -> A
        let result = resolver.resolve("circular-a").await;
        
        assert!(result.is_err());
        assert!(matches!(
            result.unwrap_err(),
            Error::CircularDependency(_)
        ));
    }
    
    // 版本兼容性测试
    #[test]
    fn test_version_compatibility() {
        let required = VersionReq::parse("^1.2.0").unwrap();
        
        assert!(required.matches(&Version::parse("1.2.5").unwrap()));
        assert!(required.matches(&Version::parse("1.9.0").unwrap()));
        assert!(!required.matches(&Version::parse("2.0.0").unwrap()));
    }
    
    // 模块卸载测试
    #[tokio::test]
    async fn test_unload_module() {
        let manager = ModuleManager::new(vec!["./test-modules".into()]);
        
        manager.load("test-module").await.unwrap();
        
        let result = manager.unload("test-module").await;
        assert!(result.is_ok());
        
        let state = manager.get_state("test-module").await;
        assert_eq!(state, Some(ModuleState::Unloaded));
    }
}
```

### 3.3 文件识别系统测试

**测试文件**: `tests/file_test.rs`

```rust
#[cfg(test)]
mod file_tests {
    use chips_core::file::*;
    
    // 扩展名识别测试
    #[test]
    fn test_extension_detection() {
        let detector = ExtensionDetector::new();
        
        assert_eq!(
            detector.detect(Path::new("test.cchips")),
            Some(FileType::ChipsCard)
        );
        
        assert_eq!(
            detector.detect(Path::new("test.mp4")),
            Some(FileType::Video)
        );
    }
    
    // 魔数检测测试
    #[tokio::test]
    async fn test_magic_number_detection() {
        let detector = MagicDetector::new();
        
        // PNG文件魔数: 89 50 4E 47
        let png_file = Path::new("test-files/image.png");
        let file_type = detector.detect(png_file).await.unwrap();
        
        assert_eq!(file_type, Some(FileType::Image(ImageFormat::PNG)));
    }
    
    // 卡片文件解析测试
    #[tokio::test]
    async fn test_card_parsing() {
        let parser = CardParser::new();
        
        let card_path = Path::new("test-files/todo.cchips");
        let card = parser.parse(card_path).await.unwrap();
        
        assert_eq!(card.metadata.card_type, "todo");
        assert_eq!(card.metadata.version, "1.0.0");
    }
    
    // 文件验证测试
    #[tokio::test]
    async fn test_file_validation() {
        let recognizer = FileRecognizer::new();
        
        // 有效文件
        let valid = recognizer.validate(Path::new("test.cchips")).await;
        assert!(valid.is_ok());
        
        // 损坏的文件
        let corrupted = recognizer.validate(Path::new("corrupted.cchips")).await;
        assert!(corrupted.is_err());
    }
}
```

### 3.4 资源管理系统测试

**测试文件**: `tests/resource_test.rs`

```rust
#[cfg(test)]
mod resource_tests {
    use chips_core::resource::*;
    
    // 本地文件读取测试
    #[tokio::test]
    async fn test_local_file_read() {
        let manager = ResourceManager::new();
        
        let data = manager.read("file://test.txt").await.unwrap();
        assert!(!data.is_empty());
    }
    
    // HTTP资源读取测试
    #[tokio::test]
    async fn test_http_resource() {
        let manager = ResourceManager::new();
        
        let data = manager
            .read("https://example.com/resource")
            .await
            .unwrap();
        
        assert!(!data.is_empty());
    }
    
    // 缓存测试
    #[tokio::test]
    async fn test_resource_cache() {
        let manager = ResourceManager::new();
        
        // 第一次读取
        let start = Instant::now();
        let data1 = manager.read("http://example.com/large").await.unwrap();
        let first_time = start.elapsed();
        
        // 第二次读取（应该从缓存）
        let start = Instant::now();
        let data2 = manager.read("http://example.com/large").await.unwrap();
        let second_time = start.elapsed();
        
        assert_eq!(data1, data2);
        assert!(second_time < first_time / 10); // 缓存应快10倍以上
    }
    
    // 路径解析测试
    #[test]
    fn test_path_resolution() {
        let resolver = PathResolver::new();
        
        let resolved = resolver.resolve("file://./test.txt").unwrap();
        assert_eq!(resolved.scheme, "file");
        assert!(resolved.path.is_absolute());
        
        let resolved = resolver.resolve("https://example.com/test").unwrap();
        assert_eq!(resolved.scheme, "https");
        assert_eq!(resolved.url, "https://example.com/test");
    }
}
```

## 4. 测试覆盖率要求

### 4.1 覆盖率目标

**核心模块**
- 路由系统: 90%+
- 模块管理: 90%+
- 文件识别: 85%+
- 资源管理: 85%+

**支撑模块**
- 配置管理: 80%+
- 日志系统: 70%+
- 工具函数: 85%+

### 4.2 生成覆盖率报告

**安装工具**
```bash
cargo install cargo-tarpaulin
```

**运行覆盖率测试**
```bash
# 生成HTML报告
cargo tarpaulin --out Html --output-dir coverage

# 生成Cobertura报告（用于CI）
cargo tarpaulin --out Xml

# 排除测试代码
cargo tarpaulin --exclude-files tests/
```

**配置文件 tarpaulin.toml**
```toml
[report]
coveralls = false
html = true
xml = true

[run]
timeout = 300
exclude-files = [
    "tests/*",
    "benches/*",
]
```

## 5. 测试流程和CI/CD集成

### 5.1 本地测试流程

```bash
# 1. 运行单元测试
cargo test

# 2. 运行性能测试
cargo bench

# 3. 检查代码覆盖率
cargo tarpaulin --out Html

# 4. 代码检查
cargo clippy -- -D warnings

# 5. 格式检查
cargo fmt -- --check
```

### 5.2 CI配置（GitHub Actions）

**配置文件 .github/workflows/test.yml**

```yaml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, nightly]
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ matrix.rust }}
          override: true
      
      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
      
      - name: Run tests
        run: cargo test --verbose
      
      - name: Run clippy
        run: cargo clippy -- -D warnings
      
      - name: Check formatting
        run: cargo fmt -- --check
  
  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install tarpaulin
        run: cargo install cargo-tarpaulin
      
      - name: Generate coverage
        run: cargo tarpaulin --out Xml
      
      - name: Upload to codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./cobertura.xml
```

## 6. Mock和Stub策略

### 6.1 使用Mock对象

```rust
use mockall::*;

#[automock]
pub trait ModuleLoader {
    fn load(&self, module_id: &str) -> Result<Module>;
    fn unload(&self, module_id: &str) -> Result<()>;
}

#[test]
fn test_with_mock_loader() {
    let mut mock_loader = MockModuleLoader::new();
    
    // 设置期望
    mock_loader
        .expect_load()
        .with(eq("test-module"))
        .times(1)
        .returning(|_| Ok(Module::new()));
    
    // 使用mock
    let result = mock_loader.load("test-module");
    assert!(result.is_ok());
}
```

### 6.2 使用Stub数据

```rust
// 创建测试数据
fn create_test_card() -> Card {
    Card {
        id: "test123".to_string(),
        card_type: "todo".to_string(),
        content: CardContent::Todo(TodoContent {
            title: "Test".to_string(),
            completed: false,
        }),
        metadata: CardMetadata::default(),
    }
}

#[test]
fn test_with_stub_data() {
    let card = create_test_card();
    
    assert_eq!(card.card_type, "todo");
    // 更多测试...
}
```

### 6.3 测试替身模式

```rust
// 真实实现
pub struct RealResourceProvider {
    // ...
}

// 测试用假实现
pub struct FakeResourceProvider {
    data: HashMap<String, Vec<u8>>,
}

impl FakeResourceProvider {
    pub fn new() -> Self {
        let mut data = HashMap::new();
        data.insert("test.txt".to_string(), b"test data".to_vec());
        Self { data }
    }
}

impl ResourceProvider for FakeResourceProvider {
    async fn read(&self, path: &str) -> Result<Vec<u8>> {
        self.data
            .get(path)
            .cloned()
            .ok_or_else(|| Error::NotFound(path.to_string()))
    }
}

#[tokio::test]
async fn test_with_fake_provider() {
    let provider = FakeResourceProvider::new();
    let data = provider.read("test.txt").await.unwrap();
    assert_eq!(data, b"test data");
}
```

## 7. 性能测试

### 7.1 路由性能基准

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn route_benchmark(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let router = Router::new();
    
    c.bench_function("route_request", |b| {
        b.to_async(&rt).iter(|| async {
            let request = RouteRequest {
                action: "test.action".to_string(),
                ..Default::default()
            };
            router.route(black_box(request)).await
        });
    });
}

criterion_group!(benches, route_benchmark);
criterion_main!(benches);
```

### 7.2 内存使用测试

```rust
#[test]
fn test_memory_usage() {
    use std::mem;
    
    // 检查结构体大小
    assert!(mem::size_of::<RouteRequest>() < 1024); // < 1KB
    assert!(mem::size_of::<Window>() < 512); // < 512B
}
```

## 8. 测试最佳实践

### 8.1 测试命名

```rust
// 好的命名
#[test]
fn test_route_request_with_valid_action_returns_success() { }

// 不好的命名
#[test]
fn test1() { }
```

### 8.2 测试组织

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    mod route_table {
        use super::*;
        
        #[test]
        fn test_add_route() { }
        
        #[test]
        fn test_remove_route() { }
    }
    
    mod route_request {
        use super::*;
        
        #[test]
        fn test_validate() { }
    }
}
```

### 8.3 测试数据管理

```rust
// 使用fixtures目录
const TEST_DATA_DIR: &str = "tests/fixtures";

fn load_test_card() -> Card {
    let path = format!("{}/todo.cchips", TEST_DATA_DIR);
    CardParser::parse(Path::new(&path)).unwrap()
}
```

## 9. 总结

完善的测试体系是内核质量保证的关键:

1. **全面的测试覆盖**: 单元、集成、性能、安全测试
2. **自动化测试**: CI/CD集成,每次提交自动测试
3. **高覆盖率**: 核心模块90%+覆盖率
4. **性能基准**: 持续监控关键路径性能
5. **Mock和Stub**: 隔离依赖,专注测试目标
6. **清晰的测试结构**: 易于维护和扩展

通过系统化的测试,确保内核的稳定性、可靠性和性能。
