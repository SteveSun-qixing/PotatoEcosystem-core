# 03-模块管理系统设计

## 3.1 系统概述

模块管理系统负责模块的整个生命周期管理，包括扫描、注册、加载、卸载、依赖解析、版本管理、健康检查等。

**核心职责**：
- 扫描和发现模块
- 维护模块注册表
- 解析和管理依赖关系
- 加载和初始化模块
- 管理模块生命周期
- 模块热插拔支持
- 健康检查和异常恢复

## 3.2 模块元数据设计

### 3.2.1 module.yaml 格式

每个模块都必须包含一个`module.yaml`文件，描述模块的元数据。

```yaml
# module.yaml 示例

# 模块基本信息
id: "video-card-plugin"
name: "视频卡片插件"
version: "1.2.3"
description: "支持视频卡片的编辑和渲染"
author: "Chips Team"
license: "MIT"
homepage: "https://chips.example.com/plugins/video-card"

# 模块类型
type: "plugin"  # plugin | service | renderer | processor

# 入口点
entry:
  # 主入口文件
  main: "dist/index.js"
  # 入口类型：js | python | wasm | native
  runtime: "js"

# 依赖关系
dependencies:
  # 依赖其他模块
  - id: "video-decoder"
    version: "^2.0.0"  # 语义化版本范围
    optional: false
  
  - id: "subtitle-renderer"
    version: ">=1.5.0 <2.0.0"
    optional: true  # 可选依赖

# 提供的接口
interfaces:
  # 处理的action类型
  actions:
    - "editVideoCard"
    - "renderVideoCard"
    - "exportVideo"
  
  # 处理的文件类型
  file_types:
    - extension: ".mp4"
      mime_type: "video/mp4"
      priority: 10
    - extension: ".mov"
      mime_type: "video/quicktime"
      priority: 10

# 需要的权限
permissions:
  - "file.read"
  - "file.write"
  - "network.http"
  - "media.encode"

# 配置schema
config_schema:
  type: "object"
  properties:
    max_video_size:
      type: "integer"
      default: 1073741824  # 1GB
    supported_codecs:
      type: "array"
      items:
        type: "string"
      default: ["h264", "h265", "vp9"]

# 资源需求
resources:
  min_memory_mb: 100
  max_memory_mb: 500
  requires_gpu: false

# 兼容性
compatibility:
  core_version: "^1.0.0"  # 需要的内核版本
  platforms:  # 支持的平台
    - "win32"
    - "darwin"
    - "linux"
  architectures:  # 支持的架构
    - "x64"
    - "arm64"

# 可选：扩展信息
metadata:
  icon: "assets/icon.png"
  screenshots:
    - "assets/screenshot1.png"
    - "assets/screenshot2.png"
  tags:
    - "video"
    - "media"
    - "card"
```

### 3.2.2 模块元数据结构

```rust
/// 模块元数据
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ModuleMetadata {
    // 基本信息
    pub id: String,
    pub name: String,
    pub version: Version,  // semver::Version
    pub description: Option<String>,
    pub author: Option<String>,
    pub license: Option<String>,
    pub homepage: Option<String>,
    
    // 模块类型
    pub module_type: ModuleType,
    
    // 入口点
    pub entry: EntryPoint,
    
    // 依赖关系
    pub dependencies: Vec<Dependency>,
    
    // 接口定义
    pub interfaces: ModuleInterfaces,
    
    // 权限
    pub permissions: Vec<String>,
    
    // 配置schema
    pub config_schema: Option<Value>,
    
    // 资源需求
    pub resources: ResourceRequirements,
    
    // 兼容性
    pub compatibility: Compatibility,
    
    // 扩展元数据
    pub metadata: HashMap<String, Value>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "lowercase")]
pub enum ModuleType {
    Plugin,
    Service,
    Renderer,
    Processor,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EntryPoint {
    pub main: String,
    pub runtime: Runtime,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "lowercase")]
pub enum Runtime {
    Js,
    Python,
    Wasm,
    Native,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Dependency {
    pub id: String,
    pub version: VersionReq,  // semver::VersionReq
    pub optional: bool,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ModuleInterfaces {
    pub actions: Vec<String>,
    pub file_types: Vec<FileTypeHandler>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FileTypeHandler {
    pub extension: String,
    pub mime_type: Option<String>,
    pub priority: i32,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ResourceRequirements {
    pub min_memory_mb: u64,
    pub max_memory_mb: u64,
    pub requires_gpu: bool,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Compatibility {
    pub core_version: VersionReq,
    pub platforms: Vec<String>,
    pub architectures: Vec<String>,
}
```

## 3.3 模块注册表设计

### 3.3.1 注册表数据结构

```rust
/// 模块注册表
pub struct ModuleRegistry {
    /// 已注册的模块：module_id -> ModuleInfo
    modules: Arc<RwLock<HashMap<String, ModuleInfo>>>,
    
    /// 模块状态：module_id -> ModuleState
    states: Arc<RwLock<HashMap<String, ModuleState>>>,
    
    /// 依赖图
    dependency_graph: Arc<RwLock<DependencyGraph>>,
    
    /// 模块目录路径
    module_dirs: Vec<PathBuf>,
}

/// 模块信息
#[derive(Debug, Clone)]
pub struct ModuleInfo {
    /// 元数据
    pub metadata: ModuleMetadata,
    
    /// 模块路径
    pub path: PathBuf,
    
    /// 注册时间
    pub registered_at: DateTime<Utc>,
    
    /// 最后加载时间
    pub last_loaded_at: Option<DateTime<Utc>>,
    
    /// 加载次数
    pub load_count: u64,
}

/// 模块状态
#[derive(Debug, Clone, PartialEq)]
pub enum ModuleState {
    /// 未加载
    Unloaded,
    
    /// 加载中
    Loading,
    
    /// 已加载并运行中
    Running,
    
    /// 错误状态
    Error(String),
    
    /// 已卸载
    Unloaded,
}
```

### 3.3.2 注册表操作接口

```rust
impl ModuleRegistry {
    /// 创建注册表
    pub fn new(module_dirs: Vec<PathBuf>) -> Self;
    
    /// 扫描模块目录
    pub async fn scan(&self) -> Result<Vec<String>>;
    
    /// 注册单个模块
    pub async fn register(&self, module_path: &Path) -> Result<String>;
    
    /// 取消注册模块
    pub async fn unregister(&self, module_id: &str) -> Result<()>;
    
    /// 获取模块信息
    pub async fn get_module(&self, module_id: &str) -> Option<ModuleInfo>;
    
    /// 获取所有模块
    pub async fn list_modules(&self) -> Vec<ModuleInfo>;
    
    /// 获取模块状态
    pub async fn get_state(&self, module_id: &str) -> Option<ModuleState>;
    
    /// 设置模块状态
    pub async fn set_state(&self, module_id: &str, state: ModuleState) -> Result<()>;
    
    /// 检查模块是否存在
    pub async fn exists(&self, module_id: &str) -> bool;
    
    /// 查找模块（按条件）
    pub async fn find_modules(&self, predicate: impl Fn(&ModuleInfo) -> bool) -> Vec<ModuleInfo>;
}
```

## 3.4 依赖解析设计

### 3.4.1 依赖图

```rust
/// 依赖图
pub struct DependencyGraph {
    /// 节点：module_id -> 依赖列表
    edges: HashMap<String, Vec<String>>,
    
    /// 反向边：module_id -> 被依赖列表
    reverse_edges: HashMap<String, Vec<String>>,
}

impl DependencyGraph {
    /// 添加依赖关系
    pub fn add_dependency(&mut self, module_id: &str, dependency_id: &str) {
        self.edges
            .entry(module_id.to_string())
            .or_insert_with(Vec::new)
            .push(dependency_id.to_string());
        
        self.reverse_edges
            .entry(dependency_id.to_string())
            .or_insert_with(Vec::new)
            .push(module_id.to_string());
    }
    
    /// 获取模块的所有依赖
    pub fn get_dependencies(&self, module_id: &str) -> Vec<String> {
        self.edges.get(module_id).cloned().unwrap_or_default()
    }
    
    /// 获取依赖该模块的所有模块
    pub fn get_dependents(&self, module_id: &str) -> Vec<String> {
        self.reverse_edges.get(module_id).cloned().unwrap_or_default()
    }
    
    /// 检测循环依赖
    pub fn has_cycle(&self) -> bool {
        // 使用DFS检测环
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();
        
        for node in self.edges.keys() {
            if self.has_cycle_util(node, &mut visited, &mut rec_stack) {
                return true;
            }
        }
        
        false
    }
    
    fn has_cycle_util(
        &self,
        node: &str,
        visited: &mut HashSet<String>,
        rec_stack: &mut HashSet<String>,
    ) -> bool {
        if rec_stack.contains(node) {
            return true;
        }
        
        if visited.contains(node) {
            return false;
        }
        
        visited.insert(node.to_string());
        rec_stack.insert(node.to_string());
        
        if let Some(neighbors) = self.edges.get(node) {
            for neighbor in neighbors {
                if self.has_cycle_util(neighbor, visited, rec_stack) {
                    return true;
                }
            }
        }
        
        rec_stack.remove(node);
        false
    }
    
    /// 拓扑排序（确定加载顺序）
    pub fn topological_sort(&self) -> Result<Vec<String>> {
        if self.has_cycle() {
            return Err(Error::CircularDependency);
        }
        
        let mut in_degree: HashMap<String, usize> = HashMap::new();
        for node in self.edges.keys() {
            in_degree.insert(node.clone(), 0);
        }
        
        for edges in self.edges.values() {
            for node in edges {
                *in_degree.entry(node.clone()).or_insert(0) += 1;
            }
        }
        
        let mut queue: VecDeque<String> = in_degree
            .iter()
            .filter(|(_, &degree)| degree == 0)
            .map(|(node, _)| node.clone())
            .collect();
        
        let mut result = Vec::new();
        
        while let Some(node) = queue.pop_front() {
            result.push(node.clone());
            
            if let Some(neighbors) = self.edges.get(&node) {
                for neighbor in neighbors {
                    if let Some(degree) = in_degree.get_mut(neighbor) {
                        *degree -= 1;
                        if *degree == 0 {
                            queue.push_back(neighbor.clone());
                        }
                    }
                }
            }
        }
        
        if result.len() != self.edges.len() {
            return Err(Error::CircularDependency);
        }
        
        Ok(result)
    }
}
```

### 3.4.2 依赖解析器

```rust
pub struct DependencyResolver {
    registry: Arc<ModuleRegistry>,
}

impl DependencyResolver {
    /// 解析模块的所有依赖
    pub async fn resolve(&self, module_id: &str) -> Result<Vec<String>> {
        let mut resolved = Vec::new();
        let mut visited = HashSet::new();
        
        self.resolve_recursive(module_id, &mut resolved, &mut visited).await?;
        
        Ok(resolved)
    }
    
    /// 递归解析依赖
    async fn resolve_recursive(
        &self,
        module_id: &str,
        resolved: &mut Vec<String>,
        visited: &mut HashSet<String>,
    ) -> Result<()> {
        if visited.contains(module_id) {
            return Ok(());
        }
        
        visited.insert(module_id.to_string());
        
        // 获取模块信息
        let module_info = self.registry.get_module(module_id).await
            .ok_or_else(|| Error::ModuleNotFound(module_id.to_string()))?;
        
        // 解析每个依赖
        for dep in &module_info.metadata.dependencies {
            // 检查依赖模块是否存在
            let dep_module = self.registry.get_module(&dep.id).await
                .ok_or_else(|| Error::DependencyNotFound(dep.id.clone()))?;
            
            // 检查版本兼容性
            if !dep.version.matches(&dep_module.metadata.version) {
                return Err(Error::VersionMismatch {
                    module: dep.id.clone(),
                    required: dep.version.to_string(),
                    found: dep_module.metadata.version.to_string(),
                });
            }
            
            // 递归解析依赖的依赖
            self.resolve_recursive(&dep.id, resolved, visited).await?;
        }
        
        // 将当前模块加入已解析列表
        resolved.push(module_id.to_string());
        
        Ok(())
    }
    
    /// 检查依赖冲突
    pub async fn check_conflicts(&self, modules: &[String]) -> Result<()> {
        // 检查是否有相同模块的不同版本要求
        let mut version_requirements: HashMap<String, Vec<VersionReq>> = HashMap::new();
        
        for module_id in modules {
            let module_info = self.registry.get_module(module_id).await
                .ok_or_else(|| Error::ModuleNotFound(module_id.clone()))?;
            
            for dep in &module_info.metadata.dependencies {
                version_requirements
                    .entry(dep.id.clone())
                    .or_insert_with(Vec::new)
                    .push(dep.version.clone());
            }
        }
        
        // 检查版本要求是否兼容
        for (dep_id, requirements) in version_requirements {
            if requirements.len() > 1 {
                // 检查所有要求是否有交集
                // 简化实现：检查是否所有要求都接受同一个版本
                if let Some(dep_info) = self.registry.get_module(&dep_id).await {
                    for req in &requirements {
                        if !req.matches(&dep_info.metadata.version) {
                            return Err(Error::DependencyConflict {
                                module: dep_id.clone(),
                                requirements: requirements.iter().map(|r| r.to_string()).collect(),
                            });
                        }
                    }
                }
            }
        }
        
        Ok(())
    }
}
```

## 3.5 模块加载器设计

### 3.5.1 加载器接口

```rust
/// 模块加载器
pub struct ModuleLoader {
    registry: Arc<ModuleRegistry>,
    dependency_resolver: Arc<DependencyResolver>,
    runtime_managers: HashMap<Runtime, Box<dyn RuntimeManager>>,
}

impl ModuleLoader {
    /// 加载模块
    pub async fn load(&self, module_id: &str) -> Result<ModuleInstance> {
        // 1. 检查模块是否已加载
        if let Some(state) = self.registry.get_state(module_id).await {
            if state == ModuleState::Running {
                return Err(Error::ModuleAlreadyLoaded(module_id.to_string()));
            }
        }
        
        // 2. 设置状态为加载中
        self.registry.set_state(module_id, ModuleState::Loading).await?;
        
        // 3. 解析依赖
        let dependencies = match self.dependency_resolver.resolve(module_id).await {
            Ok(deps) => deps,
            Err(e) => {
                self.registry.set_state(module_id, ModuleState::Error(e.to_string())).await?;
                return Err(e);
            }
        };
        
        // 4. 加载所有依赖（除了自己）
        for dep_id in &dependencies {
            if dep_id != module_id {
                if let Some(state) = self.registry.get_state(dep_id).await {
                    if state != ModuleState::Running {
                        // 依赖未加载，递归加载
                        self.load(dep_id).await?;
                    }
                }
            }
        }
        
        // 5. 获取模块信息
        let module_info = self.registry.get_module(module_id).await
            .ok_or_else(|| Error::ModuleNotFound(module_id.to_string()))?;
        
        // 6. 根据运行时类型加载模块代码
        let runtime_manager = self.runtime_managers.get(&module_info.metadata.entry.runtime)
            .ok_or_else(|| Error::UnsupportedRuntime(module_info.metadata.entry.runtime.clone()))?;
        
        let instance = match runtime_manager.load_module(&module_info).await {
            Ok(inst) => inst,
            Err(e) => {
                self.registry.set_state(module_id, ModuleState::Error(e.to_string())).await?;
                return Err(e);
            }
        };
        
        // 7. 初始化模块
        if let Err(e) = instance.initialize().await {
            self.registry.set_state(module_id, ModuleState::Error(e.to_string())).await?;
            return Err(e);
        }
        
        // 8. 设置状态为运行中
        self.registry.set_state(module_id, ModuleState::Running).await?;
        
        // 9. 记录加载时间
        // ...
        
        Ok(instance)
    }
    
    /// 卸载模块
    pub async fn unload(&self, module_id: &str) -> Result<()> {
        // 1. 检查是否有其他模块依赖此模块
        let dependents = self.registry.get_dependency_graph()
            .await
            .get_dependents(module_id);
        
        if !dependents.is_empty() {
            return Err(Error::ModuleHasDependents {
                module: module_id.to_string(),
                dependents,
            });
        }
        
        // 2. 获取模块实例
        let instance = self.get_instance(module_id).await
            .ok_or_else(|| Error::ModuleNotLoaded(module_id.to_string()))?;
        
        // 3. 调用模块的清理函数
        instance.cleanup().await?;
        
        // 4. 卸载模块代码
        let module_info = self.registry.get_module(module_id).await.unwrap();
        let runtime_manager = self.runtime_managers.get(&module_info.metadata.entry.runtime).unwrap();
        runtime_manager.unload_module(module_id).await?;
        
        // 5. 设置状态为已卸载
        self.registry.set_state(module_id, ModuleState::Unloaded).await?;
        
        Ok(())
    }
}
```

### 3.5.2 运行时管理器

```rust
/// 运行时管理器trait
#[async_trait]
pub trait RuntimeManager: Send + Sync {
    /// 加载模块
    async fn load_module(&self, module_info: &ModuleInfo) -> Result<ModuleInstance>;
    
    /// 卸载模块
    async fn unload_module(&self, module_id: &str) -> Result<()>;
    
    /// 获取运行时类型
    fn runtime_type(&self) -> Runtime;
}

/// JavaScript运行时管理器
pub struct JsRuntimeManager {
    // V8 isolates池或Deno runtime
    // ...
}

#[async_trait]
impl RuntimeManager for JsRuntimeManager {
    async fn load_module(&self, module_info: &ModuleInfo) -> Result<ModuleInstance> {
        // 1. 读取模块文件
        let entry_path = module_info.path.join(&module_info.metadata.entry.main);
        let code = tokio::fs::read_to_string(&entry_path).await?;
        
        // 2. 创建JS运行时环境
        // 使用V8或Deno
        // ...
        
        // 3. 加载模块代码
        // ...
        
        // 4. 创建模块实例
        Ok(ModuleInstance {
            id: module_info.metadata.id.clone(),
            runtime: Runtime::Js,
            // ...
        })
    }
    
    async fn unload_module(&self, module_id: &str) -> Result<()> {
        // 销毁JS运行时环境
        // ...
        Ok(())
    }
    
    fn runtime_type(&self) -> Runtime {
        Runtime::Js
    }
}

/// Python运行时管理器
pub struct PythonRuntimeManager {
    // PyO3相关
    // ...
}

// 类似实现...

/// WASM运行时管理器
pub struct WasmRuntimeManager {
    // Wasmtime相关
    // ...
}

// 类似实现...
```

### 3.5.3 模块实例

```rust
/// 模块实例
pub struct ModuleInstance {
    /// 模块ID
    pub id: String,
    
    /// 运行时类型
    pub runtime: Runtime,
    
    /// 实例句柄（根据运行时类型不同）
    pub handle: ModuleHandle,
    
    /// 启动时间
    pub started_at: DateTime<Utc>,
}

/// 模块句柄（enum包装不同运行时的句柄）
pub enum ModuleHandle {
    Js(JsModuleHandle),
    Python(PythonModuleHandle),
    Wasm(WasmModuleHandle),
    Native(NativeModuleHandle),
}

impl ModuleInstance {
    /// 初始化模块
    pub async fn initialize(&self) -> Result<()> {
        match &self.handle {
            ModuleHandle::Js(handle) => handle.call_init().await,
            ModuleHandle::Python(handle) => handle.call_init().await,
            ModuleHandle::Wasm(handle) => handle.call_init().await,
            ModuleHandle::Native(handle) => handle.call_init().await,
        }
    }
    
    /// 调用模块方法
    pub async fn call_method(&self, method: &str, params: Value) -> Result<Value> {
        match &self.handle {
            ModuleHandle::Js(handle) => handle.call(method, params).await,
            // ...
            _ => unimplemented!(),
        }
    }
    
    /// 清理模块
    pub async fn cleanup(&self) -> Result<()> {
        match &self.handle {
            ModuleHandle::Js(handle) => handle.call_cleanup().await,
            // ...
            _ => Ok(()),
        }
    }
}
```

## 3.6 生命周期管理

### 3.6.1 生命周期钩子

每个模块可以实现以下生命周期钩子：

```javascript
// JavaScript模块示例

export default {
  // 模块初始化
  async onInit() {
    console.log('Module initializing...');
    // 初始化资源、连接数据库等
  },
  
  // 模块启动
  async onStart() {
    console.log('Module started');
    // 启动后台任务等
  },
  
  // 模块停止
  async onStop() {
    console.log('Module stopping...');
    // 停止后台任务
  },
  
  // 模块清理
  async onCleanup() {
    console.log('Module cleaning up...');
    // 关闭连接、释放资源等
  },
  
  // 健康检查
  async onHealthCheck() {
    return { status: 'healthy', details: {} };
  },
};
```

### 3.6.2 生命周期管理器

```rust
pub struct LifecycleManager {
    instances: Arc<RwLock<HashMap<String, ModuleInstance>>>,
}

impl LifecycleManager {
    /// 启动模块
    pub async fn start(&self, module_id: &str) -> Result<()> {
        let instance = self.get_instance(module_id).await?;
        instance.call_method("onStart", json!({})).await?;
        Ok(())
    }
    
    /// 停止模块
    pub async fn stop(&self, module_id: &str) -> Result<()> {
        let instance = self.get_instance(module_id).await?;
        instance.call_method("onStop", json!({})).await?;
        Ok(())
    }
    
    /// 健康检查
    pub async fn health_check(&self, module_id: &str) -> Result<HealthStatus> {
        let instance = self.get_instance(module_id).await?;
        let result = instance.call_method("onHealthCheck", json!({})).await?;
        
        Ok(serde_json::from_value(result)?)
    }
    
    /// 定期健康检查（后台任务）
    pub async fn start_health_check_loop(&self) {
        let instances = Arc::clone(&self.instances);
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(30));
            
            loop {
                interval.tick().await;
                
                let instances_guard = instances.read().await;
                for (module_id, _) in instances_guard.iter() {
                    // 执行健康检查
                    // ...
                }
            }
        });
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct HealthStatus {
    pub status: String,  // "healthy" | "degraded" | "unhealthy"
    pub details: HashMap<String, Value>,
}
```

## 3.7 热插拔支持

### 3.7.1 热加载

```rust
impl ModuleManager {
    /// 热安装模块
    pub async fn hot_install(&self, module_path: &Path) -> Result<String> {
        // 1. 注册模块
        let module_id = self.registry.register(module_path).await?;
        
        // 2. 立即加载模块
        self.loader.load(&module_id).await?;
        
        // 3. 注册路由规则
        self.register_routes(&module_id).await?;
        
        // 4. 触发模块安装事件
        self.event_bus.broadcast(Event {
            event_id: Uuid::new_v4().to_string(),
            event_type: "module.installed".to_string(),
            sender: "core".to_string(),
            data: json!({ "module_id": module_id }),
            timestamp: Utc::now(),
        }).await;
        
        Ok(module_id)
    }
    
    /// 热更新模块
    pub async fn hot_update(&self, module_id: &str, new_module_path: &Path) -> Result<()> {
        // 1. 保存模块状态
        let state = self.save_module_state(module_id).await?;
        
        // 2. 卸载旧版本
        self.loader.unload(module_id).await?;
        
        // 3. 取消注册旧版本
        self.registry.unregister(module_id).await?;
        
        // 4. 注册新版本
        self.registry.register(new_module_path).await?;
        
        // 5. 加载新版本
        self.loader.load(module_id).await?;
        
        // 6. 恢复模块状态（如果可能）
        self.restore_module_state(module_id, state).await?;
        
        // 7. 触发更新事件
        self.event_bus.broadcast(Event {
            event_id: Uuid::new_v4().to_string(),
            event_type: "module.updated".to_string(),
            sender: "core".to_string(),
            data: json!({ "module_id": module_id }),
            timestamp: Utc::now(),
        }).await;
        
        Ok(())
    }
}
```

## 3.8 错误处理和恢复

### 3.8.1 模块崩溃处理

```rust
impl LifecycleManager {
    /// 监控模块状态
    pub async fn monitor_modules(&self) {
        let instances = Arc::clone(&self.instances);
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(10));
            
            loop {
                interval.tick().await;
                
                let instances_guard = instances.read().await;
                for (module_id, instance) in instances_guard.iter() {
                    // 检查模块是否存活
                    match instance.call_method("ping", json!({})).await {
                        Ok(_) => {
                            // 模块正常
                        }
                        Err(e) => {
                            // 模块异常
                            error!(module_id = %module_id, error = ?e, "Module crashed");
                            
                            // 尝试重启
                            drop(instances_guard);
                            let _ = Self::restart_module(module_id).await;
                            break;
                        }
                    }
                }
            }
        });
    }
    
    /// 重启模块
    async fn restart_module(module_id: &str) -> Result<()> {
        info!(module_id = %module_id, "Restarting module");
        
        // 卸载
        // ...
        
        // 重新加载
        // ...
        
        Ok(())
    }
}
```

## 3.9 配置

```yaml
# module_manager.yaml

module_manager:
  # 模块目录列表
  module_dirs:
    - "./modules"
    - "~/.chips/modules"
    - "/usr/local/chips/modules"
  
  # 是否自动扫描模块
  auto_scan: true
  
  # 扫描间隔（秒）
  scan_interval: 60
  
  # 是否自动加载模块
  auto_load: false
  
  # 模块崩溃后是否自动重启
  auto_restart: true
  
  # 最大重启次数
  max_restart_attempts: 3
  
  # 健康检查间隔（秒）
  health_check_interval: 30
  
  # 模块超时时间（秒）
  module_timeout: 60
```

---

模块管理系统是内核的另一个核心组件，负责管理整个模块生态。设计时需要考虑依赖关系、版本兼容性、热插拔等复杂场景。
