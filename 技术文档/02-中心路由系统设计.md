# 薯片微内核 - 中心路由系统设计

**版本**: 1.0.0  
**更新日期**: 2026-01-31  
**状态**: 全新设计

---

## 2.1 系统概述

中心路由系统是薯片微内核的核心组件，负责所有模块间的通信。这是生态架构中最关键的部分，确保所有模块通过统一的路由进行交互。

**核心职责**：
- 接收和验证路由请求
- 维护和查询路由表
- 转发请求到目标模块
- 管理响应返回
- 记录通信日志
- 监控路由性能

**设计目标**：
- 路由延迟 < 10ms (P95)
- 支持 ≥1000 并发请求
- 内存占用 < 10MB
- 99.9% 可用性

## 2.2 路由表设计

### 2.2.1 路由表数据结构

```rust
/// 路由表
pub struct RouteTable {
    /// 按action路由的映射
    action_routes: HashMap<String, Vec<RouteEntry>>,
    
    /// 自定义路由规则（正则表达式）
    custom_routes: Vec<CustomRouteEntry>,
    
    /// 默认路由
    default_route: Option<RouteEntry>,
    
    /// 读写锁，支持并发读
    lock: RwLock<()>,
}

/// 路由条目
pub struct RouteEntry {
    /// 目标模块ID
    pub module_id: String,
    
    /// 目标模块名称
    pub module_name: String,
    
    /// 优先级（数值越大优先级越高）
    pub priority: i32,
    
    /// 是否启用
    pub enabled: bool,
    
    /// 创建时间
    pub created_at: DateTime<Utc>,
    
    /// 更新时间
    pub updated_at: DateTime<Utc>,
}

/// 自定义路由条目
pub struct CustomRouteEntry {
    /// 匹配规则（正则表达式）
    pub pattern: Regex,
    
    /// 目标模块ID
    pub module_id: String,
    
    /// 优先级
    pub priority: i32,
    
    /// 是否启用
    pub enabled: bool,
}
```

### 2.2.2 路由规则优先级

路由查找顺序：
1. **自定义路由**（最高优先级，用户配置）
2. **Action 路由**（按action类型路由）
3. **默认路由**（最低优先级）

同一类型内，按 priority 字段排序，数值越大优先级越高。

### 2.2.3 路由表操作接口

```rust
impl RouteTable {
    /// 创建新的路由表
    pub fn new() -> Self;
    
    /// 注册 action 路由
    pub fn register_action_route(
        &mut self, 
        action: &str, 
        entry: RouteEntry
    ) -> Result<()>;
    
    /// 注册自定义路由
    pub fn register_custom_route(
        &mut self, 
        entry: CustomRouteEntry
    ) -> Result<()>;
    
    /// 查找路由
    pub fn find_route(&self, request: &RouteRequest) -> Option<&RouteEntry>;
    
    /// 移除模块的所有路由
    pub fn remove_module_routes(&mut self, module_id: &str) -> Result<()>;
    
    /// 更新路由优先级
    pub fn update_priority(
        &mut self, 
        module_id: &str, 
        action: &str, 
        priority: i32
    ) -> Result<()>;
    
    /// 导出路由表（用于调试）
    pub fn export(&self) -> String;
}
```

## 2.3 请求格式设计

### 2.3.1 请求对象

```rust
/// 路由请求
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RouteRequest {
    /// 唯一请求ID（UUID v4）
    pub request_id: String,
    
    /// 发送者模块ID
    pub sender: String,
    
    /// 请求的 action 类型
    pub action: String,
    
    /// 目标模块ID（可选，未指定则根据action查找）
    pub target: Option<String>,
    
    /// 请求参数（MessagePack格式）
    pub params: Value,
    
    /// 优先级（0-10，默认5）
    pub priority: u8,
    
    /// 超时时间（毫秒，默认30000）
    pub timeout_ms: u64,
    
    /// 时间戳（ISO 8601）
    pub timestamp: DateTime<Utc>,
    
    /// 额外的元数据
    pub metadata: HashMap<String, String>,
}

impl RouteRequest {
    /// 创建新请求
    pub fn new(sender: &str, action: &str, params: Value) -> Self;
    
    /// 设置目标模块
    pub fn with_target(mut self, target: &str) -> Self;
    
    /// 设置优先级
    pub fn with_priority(mut self, priority: u8) -> Self;
    
    /// 设置超时
    pub fn with_timeout(mut self, timeout_ms: u64) -> Self;
    
    /// 验证请求格式
    pub fn validate(&self) -> Result<(), ValidationError>;
}
```

**示例**（JSON表示）：
```json
{
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "sender": "video-editor",
  "action": "generateThumbnail",
  "target": "video-processor",
  "params": {
    "videoPath": "/path/to/video.mp4",
    "timestamp": 10.5,
    "width": 320,
    "height": 180
  },
  "priority": 5,
  "timeout_ms": 30000,
  "timestamp": "2026-01-31T12:00:00Z",
  "metadata": {}
}
```

### 2.3.2 响应对象

```rust
/// 路由响应
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RouteResponse {
    /// 关联的请求ID
    pub request_id: String,
    
    /// 状态码（类似HTTP状态码）
    pub status: u16,
    
    /// 响应数据（MessagePack格式）
    pub data: Option<Value>,
    
    /// 错误信息（如果有）
    pub error: Option<ErrorInfo>,
    
    /// 处理耗时（毫秒）
    pub elapsed_ms: u64,
    
    /// 时间戳
    pub timestamp: DateTime<Utc>,
}

/// 错误信息
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ErrorInfo {
    /// 错误码
    pub code: String,
    
    /// 错误消息
    pub message: String,
    
    /// 详细信息
    pub details: Option<String>,
    
    /// 堆栈跟踪（调试模式）
    pub stack_trace: Option<String>,
}

impl RouteResponse {
    /// 创建成功响应
    pub fn success(request_id: &str, data: Value, elapsed_ms: u64) -> Self;
    
    /// 创建错误响应
    pub fn error(
        request_id: &str, 
        status: u16, 
        error: ErrorInfo, 
        elapsed_ms: u64
    ) -> Self;
}
```

**状态码定义**：
```rust
pub mod status_code {
    /// 成功
    pub const OK: u16 = 200;
    
    /// 已接受（异步处理中）
    pub const ACCEPTED: u16 = 202;
    
    /// 请求格式错误
    pub const BAD_REQUEST: u16 = 400;
    
    /// 权限不足
    pub const FORBIDDEN: u16 = 403;
    
    /// 目标模块不存在
    pub const NOT_FOUND: u16 = 404;
    
    /// 请求超时
    pub const TIMEOUT: u16 = 408;
    
    /// 内部错误
    pub const INTERNAL_ERROR: u16 = 500;
    
    /// 服务不可用
    pub const SERVICE_UNAVAILABLE: u16 = 503;
}
```

## 2.4 路由算法设计

### 2.4.1 路由查找算法

```rust
impl Router {
    /// 查找目标模块
    pub fn find_target_module(&self, request: &RouteRequest) -> Result<String> {
        // 1. 如果请求明确指定了 target，直接使用
        if let Some(ref target) = request.target {
            if self.module_exists(target) {
                return Ok(target.clone());
            } else {
                return Err(Error::ModuleNotFound(target.clone()));
            }
        }
        
        // 2. 查找自定义路由（最高优先级）
        for custom_route in &self.route_table.custom_routes {
            if !custom_route.enabled {
                continue;
            }
            if custom_route.pattern.is_match(&request.action) {
                return Ok(custom_route.module_id.clone());
            }
        }
        
        // 3. 查找 action 路由
        if let Some(entries) = self.route_table.action_routes.get(&request.action) {
            if let Some(entry) = self.find_best_entry(entries) {
                return Ok(entry.module_id.clone());
            }
        }
        
        // 4. 使用默认路由
        if let Some(ref default_route) = self.route_table.default_route {
            return Ok(default_route.module_id.clone());
        }
        
        // 5. 找不到路由
        Err(Error::NoRouteFound(request.action.clone()))
    }
    
    /// 从多个路由条目中选择最佳的
    fn find_best_entry(&self, entries: &[RouteEntry]) -> Option<&RouteEntry> {
        entries
            .iter()
            .filter(|e| e.enabled)
            .max_by_key(|e| e.priority)
    }
}
```

### 2.4.2 请求处理流程

```rust
impl Router {
    /// 处理路由请求
    pub async fn route(&self, request: RouteRequest) -> RouteResponse {
        let start_time = Instant::now();
        let request_id = request.request_id.clone();
        
        // 1. 验证请求
        if let Err(e) = request.validate() {
            return RouteResponse::error(
                &request_id,
                status_code::BAD_REQUEST,
                ErrorInfo::from(e),
                start_time.elapsed().as_millis() as u64,
            );
        }
        
        // 2. 检查权限
        if let Err(e) = self.check_permission(&request) {
            return RouteResponse::error(
                &request_id,
                status_code::FORBIDDEN,
                ErrorInfo::from(e),
                start_time.elapsed().as_millis() as u64,
            );
        }
        
        // 3. 查找目标模块
        let target_module = match self.find_target_module(&request) {
            Ok(module_id) => module_id,
            Err(e) => {
                return RouteResponse::error(
                    &request_id,
                    status_code::NOT_FOUND,
                    ErrorInfo::from(e),
                    start_time.elapsed().as_millis() as u64,
                );
            }
        };
        
        // 4. 记录请求日志
        self.log_request(&request, &target_module);
        
        // 5. 转发请求到目标模块
        let (tx, rx) = oneshot::channel();
        if let Err(e) = self.dispatch_request(request.clone(), target_module, tx).await {
            return RouteResponse::error(
                &request_id,
                status_code::INTERNAL_ERROR,
                ErrorInfo::from(e),
                start_time.elapsed().as_millis() as u64,
            );
        }
        
        // 6. 等待响应（带超时）
        let timeout_duration = Duration::from_millis(request.timeout_ms);
        match tokio::time::timeout(timeout_duration, rx).await {
            Ok(Ok(response)) => {
                self.log_response(&response);
                response
            }
            Ok(Err(_)) => {
                RouteResponse::error(
                    &request_id,
                    status_code::INTERNAL_ERROR,
                    ErrorInfo::new("RECV_ERROR", "Failed to receive response"),
                    start_time.elapsed().as_millis() as u64,
                )
            }
            Err(_) => {
                self.log_timeout(&request_id);
                RouteResponse::error(
                    &request_id,
                    status_code::TIMEOUT,
                    ErrorInfo::new("TIMEOUT", "Request timeout"),
                    start_time.elapsed().as_millis() as u64,
                )
            }
        }
    }
}
```

## 2.5 并发处理设计

### 2.5.1 工作线程池

```rust
/// 路由处理器
pub struct RouteProcessor {
    /// 模块管理器（用于发送请求到模块）
    module_manager: Arc<ModuleManager>,
    
    /// 工作线程数
    worker_count: usize,
    
    /// 工作线程句柄
    workers: Vec<JoinHandle<()>>,
}

impl RouteProcessor {
    /// 启动处理器
    pub fn start(&mut self) {
        for i in 0..self.worker_count {
            let module_manager = Arc::clone(&self.module_manager);
            
            let handle = tokio::spawn(async move {
                Self::worker_loop(i, module_manager).await;
            });
            
            self.workers.push(handle);
        }
    }
    
    /// 工作线程循环
    async fn worker_loop(
        worker_id: usize,
        module_manager: Arc<ModuleManager>,
    ) {
        loop {
            // 从队列取出请求并处理
            // ...
        }
    }
}
```

### 2.5.2 并发控制

```rust
/// 并发限制器
pub struct ConcurrencyLimiter {
    /// 最大并发数
    max_concurrency: usize,
    
    /// 信号量
    semaphore: Arc<Semaphore>,
}

impl ConcurrencyLimiter {
    pub fn new(max_concurrency: usize) -> Self {
        Self {
            max_concurrency,
            semaphore: Arc::new(Semaphore::new(max_concurrency)),
        }
    }
    
    /// 获取许可
    pub async fn acquire(&self) -> SemaphorePermit<'_> {
        self.semaphore.acquire().await.unwrap()
    }
    
    /// 获取当前并发数
    pub fn current_concurrency(&self) -> usize {
        self.max_concurrency - self.semaphore.available_permits()
    }
}
```

## 2.6 日志和监控

### 2.6.1 路由日志

```rust
impl Router {
    /// 记录请求日志
    fn log_request(&self, request: &RouteRequest, target: &str) {
        info!(
            request_id = %request.request_id,
            sender = %request.sender,
            target = %target,
            action = %request.action,
            "Route request"
        );
    }
    
    /// 记录响应日志
    fn log_response(&self, response: &RouteResponse) {
        if response.status == status_code::OK {
            info!(
                request_id = %response.request_id,
                status = response.status,
                elapsed_ms = response.elapsed_ms,
                "Route response: success"
            );
        } else {
            warn!(
                request_id = %response.request_id,
                status = response.status,
                elapsed_ms = response.elapsed_ms,
                error = ?response.error,
                "Route response: error"
            );
        }
    }
}
```

### 2.6.2 性能监控

```rust
/// 路由统计
pub struct RouteStats {
    /// 总请求数
    pub total_requests: AtomicU64,
    
    /// 成功请求数
    pub successful_requests: AtomicU64,
    
    /// 失败请求数
    pub failed_requests: AtomicU64,
    
    /// 总耗时（毫秒）
    pub total_elapsed_ms: AtomicU64,
    
    /// 最小延迟（毫秒）
    pub min_latency_ms: AtomicU64,
    
    /// 最大延迟（毫秒）
    pub max_latency_ms: AtomicU64,
}

impl RouteStats {
    /// 记录请求
    pub fn record_request(&self, success: bool, elapsed_ms: u64) {
        self.total_requests.fetch_add(1, Ordering::Relaxed);
        self.total_elapsed_ms.fetch_add(elapsed_ms, Ordering::Relaxed);
        
        if success {
            self.successful_requests.fetch_add(1, Ordering::Relaxed);
        } else {
            self.failed_requests.fetch_add(1, Ordering::Relaxed);
        }
        
        // 更新最小/最大延迟
        self.update_min_latency(elapsed_ms);
        self.update_max_latency(elapsed_ms);
    }
    
    /// 获取平均延迟
    pub fn average_latency_ms(&self) -> f64 {
        let total = self.total_requests.load(Ordering::Relaxed);
        if total == 0 {
            return 0.0;
        }
        let elapsed = self.total_elapsed_ms.load(Ordering::Relaxed);
        elapsed as f64 / total as f64
    }
    
    /// 获取成功率
    pub fn success_rate(&self) -> f64 {
        let total = self.total_requests.load(Ordering::Relaxed);
        if total == 0 {
            return 0.0;
        }
        let successful = self.successful_requests.load(Ordering::Relaxed);
        successful as f64 / total as f64
    }
}
```

## 2.7 配置

### 2.7.1 路由系统配置

```yaml
# router.yaml
router:
  # 并发工作线程数（默认：CPU核心数 × 2）
  worker_count: 8
  
  # 默认超时时间（毫秒）
  default_timeout_ms: 30000
  
  # 最大并发请求数
  max_concurrency: 1000
  
  # 是否启用路由缓存
  enable_cache: true
  
  # 缓存大小
  cache_size: 1000
  
  # 是否记录详细日志
  verbose_logging: false
  
  # 性能监控采样率（0.0-1.0）
  monitoring_sample_rate: 0.1
```

---

**文档维护者**：Chips 生态核心团队  
**最后更新**：2026-01-31  
**状态**：✅ 生效
