# 05-资源管理系统设计

## 5.1 系统概述

资源管理系统为整个生态提供统一的资源访问接口，屏蔽本地文件、网络资源、网盘等不同来源的差异。

**核心职责**：
- 提供统一的资源访问接口
- 支持多种资源来源（本地、HTTP、WebDAV等）
- 资源缓存管理
- 认证和授权管理
- 路径解析和映射

## 5.2 整体架构

```rust
/// 资源管理器
pub struct ResourceManager {
    /// 资源提供者注册表
    providers: Arc<RwLock<HashMap<String, Box<dyn ResourceProvider>>>>,
    
    /// 路径解析器
    path_resolver: Arc<PathResolver>,
    
    /// 缓存管理器
    cache_manager: Arc<CacheManager>,
    
    /// 认证管理器
    auth_manager: Arc<AuthManager>,
}

impl ResourceManager {
    /// 读取资源
    pub async fn read(&self, resource_path: &str) -> Result<Vec<u8>> {
        // 1. 解析路径
        let resolved = self.path_resolver.resolve(resource_path).await?;
        
        // 2. 检查缓存
        if let Some(cached) = self.cache_manager.get(&resolved.url).await {
            return Ok(cached);
        }
        
        // 3. 获取对应的资源提供者
        let provider = self.get_provider(&resolved.scheme)?;
        
        // 4. 读取资源
        let data = provider.read(&resolved).await?;
        
        // 5. 保存到缓存
        if resolved.cacheable {
            self.cache_manager.put(&resolved.url, &data).await?;
        }
        
        Ok(data)
    }
    
    /// 写入资源
    pub async fn write(&self, resource_path: &str, data: &[u8]) -> Result<()> {
        let resolved = self.path_resolver.resolve(resource_path).await?;
        let provider = self.get_provider(&resolved.scheme)?;
        provider.write(&resolved, data).await
    }
    
    /// 检查资源是否存在
    pub async fn exists(&self, resource_path: &str) -> Result<bool> {
        let resolved = self.path_resolver.resolve(resource_path).await?;
        let provider = self.get_provider(&resolved.scheme)?;
        provider.exists(&resolved).await
    }
    
    /// 获取资源元信息
    pub async fn metadata(&self, resource_path: &str) -> Result<ResourceMetadata> {
        let resolved = self.path_resolver.resolve(resource_path).await?;
        let provider = self.get_provider(&resolved.scheme)?;
        provider.metadata(&resolved).await
    }
}
```

## 5.3 资源提供者

### 5.3.1 提供者接口

```rust
/// 资源提供者trait
#[async_trait]
pub trait ResourceProvider: Send + Sync {
    /// 读取资源
    async fn read(&self, resource: &ResolvedResource) -> Result<Vec<u8>>;
    
    /// 写入资源
    async fn write(&self, resource: &ResolvedResource, data: &[u8]) -> Result<()>;
    
    /// 检查资源存在性
    async fn exists(&self, resource: &ResolvedResource) -> Result<bool>;
    
    /// 获取元信息
    async fn metadata(&self, resource: &ResolvedResource) -> Result<ResourceMetadata>;
    
    /// 删除资源
    async fn delete(&self, resource: &ResolvedResource) -> Result<()>;
    
    /// 支持的scheme
    fn supported_schemes(&self) -> Vec<String>;
}
```

### 5.3.2 本地文件提供者

```rust
pub struct LocalFileProvider;

#[async_trait]
impl ResourceProvider for LocalFileProvider {
    async fn read(&self, resource: &ResolvedResource) -> Result<Vec<u8>> {
        tokio::fs::read(&resource.path).await.map_err(Into::into)
    }
    
    async fn write(&self, resource: &ResolvedResource, data: &[u8]) -> Result<()> {
        // 确保父目录存在
        if let Some(parent) = resource.path.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }
        
        tokio::fs::write(&resource.path, data).await.map_err(Into::into)
    }
    
    async fn exists(&self, resource: &ResolvedResource) -> Result<bool> {
        Ok(resource.path.exists())
    }
    
    async fn metadata(&self, resource: &ResolvedResource) -> Result<ResourceMetadata> {
        let metadata = tokio::fs::metadata(&resource.path).await?;
        
        Ok(ResourceMetadata {
            size: metadata.len(),
            modified: metadata.modified().ok(),
            mime_type: None,  // 可通过文件识别系统获取
        })
    }
    
    async fn delete(&self, resource: &ResolvedResource) -> Result<()> {
        tokio::fs::remove_file(&resource.path).await.map_err(Into::into)
    }
    
    fn supported_schemes(&self) -> Vec<String> {
        vec!["file".to_string()]
    }
}
```

### 5.3.3 HTTP提供者

```rust
pub struct HttpProvider {
    client: reqwest::Client,
    auth_manager: Arc<AuthManager>,
}

#[async_trait]
impl ResourceProvider for HttpProvider {
    async fn read(&self, resource: &ResolvedResource) -> Result<Vec<u8>> {
        let mut request = self.client.get(&resource.url);
        
        // 添加认证信息
        if let Some(auth) = self.auth_manager.get_auth(&resource.url).await? {
            request = match auth {
                Auth::Bearer(token) => request.bearer_auth(token),
                Auth::Basic(username, password) => request.basic_auth(username, Some(password)),
            };
        }
        
        let response = request.send().await?;
        
        if !response.status().is_success() {
            return Err(Error::HttpError(response.status()));
        }
        
        let data = response.bytes().await?.to_vec();
        Ok(data)
    }
    
    async fn write(&self, resource: &ResolvedResource, data: &[u8]) -> Result<()> {
        let mut request = self.client.put(&resource.url).body(data.to_vec());
        
        // 添加认证
        if let Some(auth) = self.auth_manager.get_auth(&resource.url).await? {
            request = match auth {
                Auth::Bearer(token) => request.bearer_auth(token),
                Auth::Basic(username, password) => request.basic_auth(username, Some(password)),
            };
        }
        
        let response = request.send().await?;
        
        if !response.status().is_success() {
            return Err(Error::HttpError(response.status()));
        }
        
        Ok(())
    }
    
    async fn metadata(&self, resource: &ResolvedResource) -> Result<ResourceMetadata> {
        let response = self.client.head(&resource.url).send().await?;
        
        let size = response.headers()
            .get(reqwest::header::CONTENT_LENGTH)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.parse().ok())
            .unwrap_or(0);
        
        let mime_type = response.headers()
            .get(reqwest::header::CONTENT_TYPE)
            .and_then(|v| v.to_str().ok())
            .map(|v| v.to_string());
        
        Ok(ResourceMetadata {
            size,
            modified: None,
            mime_type,
        })
    }
    
    fn supported_schemes(&self) -> Vec<String> {
        vec!["http".to_string(), "https".to_string()]
    }
}
```

### 5.3.4 WebDAV提供者

```rust
pub struct WebDAVProvider {
    client: reqwest::Client,
    auth_manager: Arc<AuthManager>,
}

#[async_trait]
impl ResourceProvider for WebDAVProvider {
    async fn read(&self, resource: &ResolvedResource) -> Result<Vec<u8>> {
        // WebDAV GET请求
        // 实现类似HTTP提供者，但支持WebDAV特定功能
        // ...
        todo!()
    }
    
    async fn write(&self, resource: &ResolvedResource, data: &[u8]) -> Result<()> {
        // WebDAV PUT请求
        todo!()
    }
    
    fn supported_schemes(&self) -> Vec<String> {
        vec!["webdav".to_string(), "dav".to_string()]
    }
}
```

## 5.4 路径解析

### 5.4.1 路径解析器

```rust
pub struct PathResolver {
    /// 当前工作目录（卡片根目录等）
    base_path: Arc<RwLock<Option<PathBuf>>>,
    
    /// 资源搜索路径列表
    search_paths: Arc<RwLock<Vec<PathBuf>>>,
}

impl PathResolver {
    /// 解析资源路径
    pub async fn resolve(&self, resource_path: &str) -> Result<ResolvedResource> {
        // 1. 检查URL scheme
        if let Some((scheme, rest)) = self.split_scheme(resource_path) {
            return self.resolve_url(scheme, rest).await;
        }
        
        // 2. 检查是否为绝对路径
        if Path::new(resource_path).is_absolute() {
            return Ok(ResolvedResource {
                url: format!("file://{}", resource_path),
                scheme: "file".to_string(),
                path: PathBuf::from(resource_path),
                cacheable: false,
            });
        }
        
        // 3. 相对路径：相对于base_path
        if let Some(ref base) = *self.base_path.read().await {
            let full_path = base.join(resource_path);
            if full_path.exists() {
                return Ok(ResolvedResource {
                    url: format!("file://{}", full_path.display()),
                    scheme: "file".to_string(),
                    path: full_path,
                    cacheable: false,
                });
            }
        }
        
        // 4. 在搜索路径中查找
        let search_paths = self.search_paths.read().await;
        for search_path in search_paths.iter() {
            let full_path = search_path.join(resource_path);
            if full_path.exists() {
                return Ok(ResolvedResource {
                    url: format!("file://{}", full_path.display()),
                    scheme: "file".to_string(),
                    path: full_path,
                    cacheable: false,
                });
            }
        }
        
        Err(Error::ResourceNotFound(resource_path.to_string()))
    }
    
    fn split_scheme(&self, path: &str) -> Option<(&str, &str)> {
        if let Some(pos) = path.find("://") {
            Some((&path[..pos], &path[pos+3..]))
        } else {
            None
        }
    }
    
    async fn resolve_url(&self, scheme: &str, rest: &str) -> Result<ResolvedResource> {
        let url = format!("{}://{}", scheme, rest);
        
        Ok(ResolvedResource {
            url: url.clone(),
            scheme: scheme.to_string(),
            path: PathBuf::new(),  // 网络资源无本地路径
            cacheable: scheme == "http" || scheme == "https",
        })
    }
}

/// 解析后的资源
#[derive(Debug, Clone)]
pub struct ResolvedResource {
    /// 完整URL
    pub url: String,
    
    /// Scheme (file, http, https, webdav等)
    pub scheme: String,
    
    /// 本地路径（如果是本地资源）
    pub path: PathBuf,
    
    /// 是否可缓存
    pub cacheable: bool,
}
```

## 5.5 缓存管理

### 5.5.1 缓存管理器

```rust
pub struct CacheManager {
    /// 缓存目录
    cache_dir: PathBuf,
    
    /// 缓存索引（URL -> 缓存路径）
    index: Arc<RwLock<HashMap<String, CacheEntry>>>,
    
    /// LRU淘汰器
    lru: Arc<Mutex<LruCache<String, ()>>>,
    
    /// 最大缓存大小（字节）
    max_size: u64,
    
    /// 当前缓存大小
    current_size: Arc<AtomicU64>,
}

#[derive(Debug, Clone)]
struct CacheEntry {
    /// 缓存文件路径
    path: PathBuf,
    
    /// 文件大小
    size: u64,
    
    /// 缓存时间
    cached_at: DateTime<Utc>,
    
    /// 过期时间（可选）
    expires_at: Option<DateTime<Utc>>,
    
    /// ETag（HTTP缓存验证）
    etag: Option<String>,
}

impl CacheManager {
    /// 获取缓存
    pub async fn get(&self, url: &str) -> Option<Vec<u8>> {
        let index = self.index.read().await;
        let entry = index.get(url)?;
        
        // 检查是否过期
        if let Some(expires_at) = entry.expires_at {
            if Utc::now() > expires_at {
                drop(index);
                self.remove(url).await.ok()?;
                return None;
            }
        }
        
        // 读取缓存文件
        tokio::fs::read(&entry.path).await.ok()
    }
    
    /// 保存到缓存
    pub async fn put(&self, url: &str, data: &[u8]) -> Result<()> {
        // 生成缓存文件路径
        let cache_key = Self::hash_url(url);
        let cache_path = self.cache_dir.join(&cache_key);
        
        // 检查缓存空间
        let data_size = data.len() as u64;
        self.ensure_space(data_size).await?;
        
        // 写入缓存文件
        tokio::fs::write(&cache_path, data).await?;
        
        // 更新索引
        let entry = CacheEntry {
            path: cache_path,
            size: data_size,
            cached_at: Utc::now(),
            expires_at: None,  // TODO: 从HTTP响应头解析
            etag: None,
        };
        
        let mut index = self.index.write().await;
        index.insert(url.to_string(), entry);
        
        // 更新LRU
        let mut lru = self.lru.lock().await;
        lru.put(url.to_string(), ());
        
        // 更新大小
        self.current_size.fetch_add(data_size, Ordering::Relaxed);
        
        Ok(())
    }
    
    /// 确保有足够空间
    async fn ensure_space(&self, required: u64) -> Result<()> {
        while self.current_size.load(Ordering::Relaxed) + required > self.max_size {
            // 淘汰最少使用的缓存
            let mut lru = self.lru.lock().await;
            if let Some((url, _)) = lru.pop_lru() {
                drop(lru);
                self.remove(&url).await?;
            } else {
                return Err(Error::CacheFull);
            }
        }
        Ok(())
    }
    
    fn hash_url(url: &str) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(url.as_bytes());
        format!("{:x}", hasher.finalize())
    }
}
```

## 5.6 认证管理

### 5.6.1 认证管理器

```rust
pub struct AuthManager {
    /// 认证信息存储（使用系统密钥链）
    keyring: Arc<Keyring>,
}

#[derive(Debug, Clone)]
pub enum Auth {
    Bearer(String),
    Basic(String, String),
    ApiKey(String),
}

impl AuthManager {
    /// 保存认证信息
    pub async fn save_auth(&self, host: &str, auth: &Auth) -> Result<()> {
        let serialized = serde_json::to_string(auth)?;
        self.keyring.set_password("chips-core", host, &serialized)?;
        Ok(())
    }
    
    /// 获取认证信息
    pub async fn get_auth(&self, url: &str) -> Result<Option<Auth>> {
        let host = Self::extract_host(url)?;
        
        match self.keyring.get_password("chips-core", &host) {
            Ok(password) => {
                let auth: Auth = serde_json::from_str(&password)?;
                Ok(Some(auth))
            }
            Err(_) => Ok(None),
        }
    }
    
    fn extract_host(url: &str) -> Result<String> {
        let parsed = url::Url::parse(url)?;
        Ok(parsed.host_str().unwrap_or("").to_string())
    }
}
```

**推荐使用keyring crate**：
```rust
use keyring::Entry;

pub struct Keyring {
    // 使用操作系统的密钥存储
    // macOS: Keychain
    // Windows: Credential Manager
    // Linux: Secret Service
}
```

## 5.7 资源元信息

```rust
/// 资源元信息
#[derive(Debug, Clone)]
pub struct ResourceMetadata {
    /// 文件大小（字节）
    pub size: u64,
    
    /// 最后修改时间
    pub modified: Option<SystemTime>,
    
    /// MIME类型
    pub mime_type: Option<String>,
}
```

## 5.8 配置

```yaml
# resource_manager.yaml

resource_manager:
  # 缓存配置
  cache:
    # 缓存目录
    dir: "~/.chips/cache/resources"
    
    # 最大缓存大小（字节）
    max_size: 1073741824  # 1GB
    
    # 默认过期时间（秒）
    default_ttl: 86400  # 24小时
  
  # 资源搜索路径
  search_paths:
    - "./resources"
    - "~/.chips/resources"
  
  # HTTP配置
  http:
    # 超时时间（秒）
    timeout: 30
    
    # 最大重试次数
    max_retries: 3
    
    # User-Agent
    user_agent: "ChipsCore/1.0"
```

---

资源管理系统提供统一的资源访问接口，是内核的重要组成部分。设计时需要考虑性能（缓存）、安全（认证）和扩展性（多种协议）。
