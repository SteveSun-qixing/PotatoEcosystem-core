# 04-文件识别系统设计

## 4.1 系统概述

文件识别系统负责识别文件类型并将文件路由到相应的处理器模块。它是用户与内核交互的第一道门槛。

**核心职责**：
- 识别文件类型（扩展名、MIME、魔数）
- 维护文件类型与处理器的映射关系
- 解析卡片和箱子文件结构
- 提供文件验证功能

## 4.2 文件类型识别

### 4.2.1 识别器架构

```rust
/// 文件识别器
pub struct FileRecognizer {
    /// 扩展名检测器
    extension_detector: ExtensionDetector,
    
    /// 魔数检测器
    magic_detector: MagicNumberDetector,
    
    /// MIME类型检测器
    mime_detector: MimeDetector,
    
    /// 文件类型表
    file_type_table: Arc<RwLock<FileTypeTable>>,
}

impl FileRecognizer {
    /// 识别文件类型
    pub async fn recognize(&self, file_path: &Path) -> Result<FileType> {
        // 1. 快速路径：扩展名检测
        if let Some(file_type) = self.extension_detector.detect(file_path)? {
            // 验证扩展名是否匹配文件内容
            if self.verify_file_type(file_path, &file_type).await? {
                return Ok(file_type);
            }
        }
        
        // 2. 魔数检测
        if let Some(file_type) = self.magic_detector.detect(file_path).await? {
            return Ok(file_type);
        }
        
        // 3. MIME类型检测
        if let Some(file_type) = self.mime_detector.detect(file_path).await? {
            return Ok(file_type);
        }
        
        // 4. 无法识别，返回未知类型
        Ok(FileType::Unknown)
    }
    
    /// 验证文件类型
    async fn verify_file_type(&self, file_path: &Path, file_type: &FileType) -> Result<bool> {
        // 读取文件头部，验证魔数
        let magic = self.read_magic_number(file_path).await?;
        
        match file_type {
            FileType::Card => Ok(magic.starts_with(&[0x50, 0x4B])), // ZIP header
            FileType::Video(codec) => self.verify_video_magic(&magic, codec),
            // ... 其他类型
            _ => Ok(true),
        }
    }
}
```

### 4.2.2 扩展名检测器

```rust
/// 扩展名检测器
pub struct ExtensionDetector {
    /// 扩展名 -> 文件类型
    mappings: HashMap<String, FileType>,
}

impl ExtensionDetector {
    /// 创建检测器
    pub fn new() -> Self {
        let mut mappings = HashMap::new();
        
        // 卡片和箱子
        mappings.insert("card".to_string(), FileType::Card);
        mappings.insert("box".to_string(), FileType::Box);
        
        // 视频
        mappings.insert("mp4".to_string(), FileType::Video(VideoCodec::H264));
        mappings.insert("mov".to_string(), FileType::Video(VideoCodec::H264));
        mappings.insert("avi".to_string(), FileType::Video(VideoCodec::Unknown));
        mappings.insert("mkv".to_string(), FileType::Video(VideoCodec::Unknown));
        mappings.insert("webm".to_string(), FileType::Video(VideoCodec::VP9));
        
        // 音频
        mappings.insert("mp3".to_string(), FileType::Audio(AudioCodec::MP3));
        mappings.insert("wav".to_string(), FileType::Audio(AudioCodec::WAV));
        mappings.insert("flac".to_string(), FileType::Audio(AudioCodec::FLAC));
        mappings.insert("ogg".to_string(), FileType::Audio(AudioCodec::Vorbis));
        
        // 图片
        mappings.insert("jpg".to_string(), FileType::Image(ImageFormat::JPEG));
        mappings.insert("jpeg".to_string(), FileType::Image(ImageFormat::JPEG));
        mappings.insert("png".to_string(), FileType::Image(ImageFormat::PNG));
        mappings.insert("gif".to_string(), FileType::Image(ImageFormat::GIF));
        mappings.insert("webp".to_string(), FileType::Image(ImageFormat::WebP));
        mappings.insert("svg".to_string(), FileType::Image(ImageFormat::SVG));
        
        // 文档
        mappings.insert("md".to_string(), FileType::Document(DocumentFormat::Markdown));
        mappings.insert("pdf".to_string(), FileType::Document(DocumentFormat::PDF));
        mappings.insert("txt".to_string(), FileType::Document(DocumentFormat::PlainText));
        mappings.insert("rtf".to_string(), FileType::Document(DocumentFormat::RTF));
        
        // 代码
        mappings.insert("js".to_string(), FileType::Code(CodeLanguage::JavaScript));
        mappings.insert("py".to_string(), FileType::Code(CodeLanguage::Python));
        mappings.insert("rs".to_string(), FileType::Code(CodeLanguage::Rust));
        mappings.insert("java".to_string(), FileType::Code(CodeLanguage::Java));
        mappings.insert("cpp".to_string(), FileType::Code(CodeLanguage::Cpp));
        
        Self { mappings }
    }
    
    /// 检测文件类型
    pub fn detect(&self, file_path: &Path) -> Result<Option<FileType>> {
        if let Some(ext) = file_path.extension() {
            let ext_str = ext.to_str().unwrap().to_lowercase();
            Ok(self.mappings.get(&ext_str).cloned())
        } else {
            Ok(None)
        }
    }
}
```

### 4.2.3 魔数检测器

```rust
/// 魔数检测器
pub struct MagicNumberDetector {
    /// 魔数 -> 文件类型
    signatures: Vec<(Vec<u8>, FileType)>,
}

impl MagicNumberDetector {
    /// 创建检测器
    pub fn new() -> Self {
        let signatures = vec![
            // ZIP (卡片文件是ZIP)
            (vec![0x50, 0x4B, 0x03, 0x04], FileType::Card),
            (vec![0x50, 0x4B, 0x05, 0x06], FileType::Card),
            
            // JPEG
            (vec![0xFF, 0xD8, 0xFF], FileType::Image(ImageFormat::JPEG)),
            
            // PNG
            (vec![0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A], FileType::Image(ImageFormat::PNG)),
            
            // GIF
            (vec![0x47, 0x49, 0x46, 0x38, 0x37, 0x61], FileType::Image(ImageFormat::GIF)),
            (vec![0x47, 0x49, 0x46, 0x38, 0x39, 0x61], FileType::Image(ImageFormat::GIF)),
            
            // WebP
            (vec![0x52, 0x49, 0x46, 0x46], FileType::Image(ImageFormat::WebP)),  // RIFF header
            
            // PDF
            (vec![0x25, 0x50, 0x44, 0x46], FileType::Document(DocumentFormat::PDF)),
            
            // MP3
            (vec![0xFF, 0xFB], FileType::Audio(AudioCodec::MP3)),
            (vec![0x49, 0x44, 0x33], FileType::Audio(AudioCodec::MP3)),  // ID3 tag
            
            // WAV
            (vec![0x52, 0x49, 0x46, 0x46], FileType::Audio(AudioCodec::WAV)),
            
            // FLAC
            (vec![0x66, 0x4C, 0x61, 0x43], FileType::Audio(AudioCodec::FLAC)),
            
            // ... 更多魔数
        ];
        
        Self { signatures }
    }
    
    /// 检测文件类型
    pub async fn detect(&self, file_path: &Path) -> Result<Option<FileType>> {
        // 读取文件头部（前16字节通常足够）
        let mut file = File::open(file_path).await?;
        let mut buffer = vec![0u8; 16];
        file.read_exact(&mut buffer).await?;
        
        // 匹配魔数
        for (signature, file_type) in &self.signatures {
            if buffer.starts_with(signature) {
                return Ok(Some(file_type.clone()));
            }
        }
        
        Ok(None)
    }
}
```

**推荐使用开源库**：
```rust
// 使用 infer crate（高质量的文件类型检测库）
use infer;

pub async fn detect_with_infer(file_path: &Path) -> Result<Option<FileType>> {
    let mut file = File::open(file_path).await?;
    let mut buffer = vec![0u8; 8192];  // infer推荐读取更多字节
    file.read(&mut buffer).await?;
    
    if let Some(kind) = infer::get(&buffer) {
        let file_type = match kind.mime_type() {
            "application/zip" => FileType::Card,  // 需要进一步验证是否为卡片
            "video/mp4" => FileType::Video(VideoCodec::H264),
            "image/jpeg" => FileType::Image(ImageFormat::JPEG),
            "image/png" => FileType::Image(ImageFormat::PNG),
            // ... 映射其他MIME类型
            _ => FileType::Unknown,
        };
        
        Ok(Some(file_type))
    } else {
        Ok(None)
    }
}
```

### 4.2.4 MIME类型检测器

```rust
/// MIME类型检测器
pub struct MimeDetector;

impl MimeDetector {
    /// 检测MIME类型
    pub async fn detect(&self, file_path: &Path) -> Result<Option<FileType>> {
        // 使用tree_magic_mini库检测MIME类型
        let mime = tree_magic_mini::from_filepath(file_path);
        
        let file_type = match mime.as_str() {
            "application/zip" => FileType::Card,
            "video/mp4" => FileType::Video(VideoCodec::H264),
            "video/quicktime" => FileType::Video(VideoCodec::H264),
            "video/x-matroska" => FileType::Video(VideoCodec::Unknown),
            "image/jpeg" => FileType::Image(ImageFormat::JPEG),
            "image/png" => FileType::Image(ImageFormat::PNG),
            "image/gif" => FileType::Image(ImageFormat::GIF),
            "audio/mpeg" => FileType::Audio(AudioCodec::MP3),
            "audio/wav" => FileType::Audio(AudioCodec::WAV),
            "application/pdf" => FileType::Document(DocumentFormat::PDF),
            "text/markdown" => FileType::Document(DocumentFormat::Markdown),
            "text/plain" => FileType::Document(DocumentFormat::PlainText),
            _ => FileType::Unknown,
        };
        
        Ok(Some(file_type))
    }
}
```

## 4.3 文件类型定义

```rust
/// 文件类型
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FileType {
    /// 卡片文件
    Card,
    
    /// 箱子文件
    Box,
    
    /// 视频文件
    Video(VideoCodec),
    
    /// 音频文件
    Audio(AudioCodec),
    
    /// 图片文件
    Image(ImageFormat),
    
    /// 文档文件
    Document(DocumentFormat),
    
    /// 代码文件
    Code(CodeLanguage),
    
    /// 压缩文件
    Archive(ArchiveFormat),
    
    /// 未知类型
    Unknown,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum VideoCodec {
    H264,
    H265,
    VP8,
    VP9,
    AV1,
    Unknown,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AudioCodec {
    MP3,
    AAC,
    Opus,
    Vorbis,
    FLAC,
    WAV,
    Unknown,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImageFormat {
    JPEG,
    PNG,
    GIF,
    WebP,
    SVG,
    BMP,
    TIFF,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DocumentFormat {
    PDF,
    Markdown,
    PlainText,
    RTF,
    HTML,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CodeLanguage {
    JavaScript,
    TypeScript,
    Python,
    Rust,
    Go,
    Java,
    Cpp,
    C,
    CSharp,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ArchiveFormat {
    Zip,
    Tar,
    Gzip,
    SevenZip,
}
```

## 4.4 卡片文件解析

### 4.4.1 卡片解析器

```rust
/// 卡片解析器
pub struct CardParser {
    /// 文件系统（用于读取ZIP内容）
    fs: Arc<FileSystem>,
}

impl CardParser {
    /// 解析卡片文件
    pub async fn parse(&self, card_path: &Path) -> Result<CardInfo> {
        // 1. 验证文件格式
        if !self.is_valid_card(card_path).await? {
            return Err(Error::InvalidCardFormat);
        }
        
        // 2. 打开ZIP文件
        let zip = self.open_zip(card_path).await?;
        
        // 3. 读取元数据
        let metadata = self.read_metadata(&zip).await?;
        
        // 4. 读取结构
        let structure = self.read_structure(&zip).await?;
        
        // 5. 读取封面信息（可选）
        let cover = self.read_cover(&zip).await.ok();
        
        Ok(CardInfo {
            path: card_path.to_path_buf(),
            metadata,
            structure,
            cover,
        })
    }
    
    /// 验证是否为有效的卡片文件
    async fn is_valid_card(&self, card_path: &Path) -> Result<bool> {
        // 1. 检查文件扩展名
        if card_path.extension() != Some(OsStr::new("card")) {
            return Ok(false);
        }
        
        // 2. 检查是否为ZIP文件
        if !self.is_zip_file(card_path).await? {
            return Ok(false);
        }
        
        // 3. 检查必需文件是否存在
        let zip = self.open_zip(card_path).await?;
        let required_files = vec![
            ".card/metadata.yaml",
            ".card/structure.yaml",
        ];
        
        for file in required_files {
            if !zip.has_file(file) {
                return Ok(false);
            }
        }
        
        Ok(true)
    }
    
    /// 读取元数据
    async fn read_metadata(&self, zip: &ZipArchive) -> Result<CardMetadata> {
        let content = zip.read_file(".card/metadata.yaml").await?;
        let metadata: CardMetadata = serde_yaml::from_str(&content)?;
        
        // 验证元数据
        metadata.validate()?;
        
        Ok(metadata)
    }
    
    /// 读取结构
    async fn read_structure(&self, zip: &ZipArchive) -> Result<CardStructure> {
        let content = zip.read_file(".card/structure.yaml").await?;
        let structure: CardStructure = serde_yaml::from_str(&content)?;
        
        Ok(structure)
    }
    
    /// 读取基础卡片配置
    pub async fn read_card_config(&self, zip: &ZipArchive, card_id: &str) -> Result<Value> {
        let config_path = format!("content/{}.yaml", card_id);
        let content = zip.read_file(&config_path).await?;
        let config: Value = serde_yaml::from_str(&content)?;
        
        Ok(config)
    }
}
```

### 4.4.2 卡片数据结构

```rust
/// 卡片信息
#[derive(Debug, Clone)]
pub struct CardInfo {
    /// 卡片文件路径
    pub path: PathBuf,
    
    /// 元数据
    pub metadata: CardMetadata,
    
    /// 结构
    pub structure: CardStructure,
    
    /// 封面
    pub cover: Option<CardCover>,
}

/// 卡片元数据
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CardMetadata {
    /// 卡片ID（10位62进制）
    pub id: String,
    
    /// 卡片名称
    pub name: String,
    
    /// 创建时间
    pub created_at: DateTime<Utc>,
    
    /// 最后修改时间
    pub updated_at: DateTime<Utc>,
    
    /// 主题包
    pub theme: String,
    
    /// 标签
    pub tags: Vec<Vec<String>>,
    
    /// 卡片格式版本
    pub chips_standards_version: String,
    
    /// 可见性
    pub visibility: Option<String>,
    
    /// 许可证
    pub license: Option<String>,
    
    /// 文件信息
    pub file_info: Option<FileInfo>,
}

impl CardMetadata {
    /// 验证元数据
    pub fn validate(&self) -> Result<()> {
        // 验证ID格式（10位62进制）
        if !Self::is_valid_id(&self.id) {
            return Err(Error::InvalidCardId(self.id.clone()));
        }
        
        // 验证名称长度
        if self.name.len() > 500 {
            return Err(Error::CardNameTooLong);
        }
        
        // 验证版本号
        if !Self::is_valid_version(&self.chips_standards_version) {
            return Err(Error::InvalidVersion(self.chips_standards_version.clone()));
        }
        
        Ok(())
    }
    
    fn is_valid_id(id: &str) -> bool {
        // 10位，只包含0-9, a-z, A-Z
        id.len() == 10 && id.chars().all(|c| c.is_alphanumeric())
    }
    
    fn is_valid_version(version: &str) -> bool {
        semver::Version::parse(version).is_ok()
    }
}

/// 卡片结构
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CardStructure {
    /// 基础卡片列表（按渲染顺序）
    pub structure: Vec<BaseCardEntry>,
    
    /// 资源清单
    pub manifest: Option<ResourceManifest>,
}

/// 基础卡片条目
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BaseCardEntry {
    /// 基础卡片ID
    pub id: String,
    
    /// 基础卡片类型
    #[serde(rename = "type")]
    pub card_type: String,
}

/// 资源清单
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ResourceManifest {
    /// 基础卡片总数
    pub card_count: usize,
    
    /// 资源文件列表
    pub resources: Vec<ResourceEntry>,
}

/// 资源条目
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ResourceEntry {
    /// 资源路径
    pub path: String,
    
    /// 文件大小（字节）
    pub size: u64,
    
    /// MIME类型
    pub mime_type: String,
    
    /// 额外信息（如视频时长、图片尺寸等）
    pub extra: Option<HashMap<String, Value>>,
}

/// 文件信息
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FileInfo {
    /// 总大小（字节）
    pub total_size: u64,
    
    /// 文件总数
    pub file_count: usize,
    
    /// SHA256校验值
    pub checksum: String,
}
```

## 4.5 文件处理器路由

### 4.5.1 处理器注册

```rust
/// 文件处理器注册表
pub struct FileHandlerRegistry {
    /// 文件类型 -> 处理器列表
    handlers: Arc<RwLock<HashMap<FileType, Vec<HandlerEntry>>>>,
}

/// 处理器条目
#[derive(Debug, Clone)]
pub struct HandlerEntry {
    /// 模块ID
    pub module_id: String,
    
    /// 优先级
    pub priority: i32,
    
    /// 是否启用
    pub enabled: bool,
}

impl FileHandlerRegistry {
    /// 注册处理器
    pub async fn register(
        &self,
        file_type: FileType,
        module_id: String,
        priority: i32,
    ) -> Result<()> {
        let mut handlers = self.handlers.write().await;
        
        let entries = handlers
            .entry(file_type.clone())
            .or_insert_with(Vec::new);
        
        // 检查是否已注册
        if entries.iter().any(|e| e.module_id == module_id) {
            return Err(Error::HandlerAlreadyRegistered {
                file_type,
                module_id,
            });
        }
        
        entries.push(HandlerEntry {
            module_id,
            priority,
            enabled: true,
        });
        
        // 按优先级排序
        entries.sort_by(|a, b| b.priority.cmp(&a.priority));
        
        Ok(())
    }
    
    /// 查找处理器
    pub async fn find_handler(&self, file_type: &FileType) -> Option<String> {
        let handlers = self.handlers.read().await;
        
        handlers.get(file_type)?
            .iter()
            .find(|e| e.enabled)
            .map(|e| e.module_id.clone())
    }
    
    /// 获取所有处理器（按优先级）
    pub async fn get_all_handlers(&self, file_type: &FileType) -> Vec<String> {
        let handlers = self.handlers.read().await;
        
        handlers.get(file_type)
            .map(|entries| {
                entries.iter()
                    .filter(|e| e.enabled)
                    .map(|e| e.module_id.clone())
                    .collect()
            })
            .unwrap_or_default()
    }
}
```

### 4.5.2 文件处理流程

```rust
impl FileRecognizer {
    /// 处理文件（完整流程）
    pub async fn process_file(&self, file_path: &Path) -> Result<()> {
        // 1. 识别文件类型
        let file_type = self.recognize(file_path).await?;
        
        // 2. 查找处理器
        let handler = self.handler_registry.find_handler(&file_type).await
            .ok_or_else(|| Error::NoHandlerFound(file_type.clone()))?;
        
        // 3. 创建处理请求
        let request = RouteRequest {
            request_id: Uuid::new_v4().to_string(),
            sender: "core".to_string(),
            action: "handleFile".to_string(),
            target: Some(handler),
            params: json!({
                "filePath": file_path.to_str().unwrap(),
                "fileType": Self::file_type_to_string(&file_type),
            }),
            priority: 5,
            timeout_ms: 30000,
            timestamp: Utc::now(),
            metadata: HashMap::new(),
            resource_type: None,
        };
        
        // 4. 通过路由系统发送请求
        let response = self.router.route(request).await;
        
        // 5. 检查响应
        if response.status != 200 {
            return Err(Error::FileProcessingFailed {
                file: file_path.to_path_buf(),
                reason: response.error.map(|e| e.message).unwrap_or_default(),
            });
        }
        
        Ok(())
    }
}
```

## 4.6 文件验证

### 4.6.1 卡片文件验证

```rust
impl CardParser {
    /// 完整验证卡片文件
    pub async fn validate(&self, card_path: &Path) -> Result<ValidationReport> {
        let mut report = ValidationReport::new();
        
        // 1. 检查文件存在性
        if !card_path.exists() {
            report.add_error("File does not exist");
            return Ok(report);
        }
        
        // 2. 检查ZIP格式
        if let Err(e) = self.is_zip_file(card_path).await {
            report.add_error(&format!("Not a valid ZIP file: {}", e));
            return Ok(report);
        }
        
        // 3. 检查必需文件
        let zip = self.open_zip(card_path).await?;
        let required_files = vec![
            ".card/metadata.yaml",
            ".card/structure.yaml",
        ];
        
        for file in &required_files {
            if !zip.has_file(file) {
                report.add_error(&format!("Missing required file: {}", file));
            }
        }
        
        if report.has_errors() {
            return Ok(report);
        }
        
        // 4. 验证元数据
        match self.read_metadata(&zip).await {
            Ok(metadata) => {
                if let Err(e) = metadata.validate() {
                    report.add_error(&format!("Invalid metadata: {}", e));
                }
            }
            Err(e) => {
                report.add_error(&format!("Failed to read metadata: {}", e));
            }
        }
        
        // 5. 验证结构
        match self.read_structure(&zip).await {
            Ok(structure) => {
                // 检查每个基础卡片的配置文件是否存在
                for entry in &structure.structure {
                    let config_path = format!("content/{}.yaml", entry.id);
                    if !zip.has_file(&config_path) {
                        report.add_warning(&format!("Missing config for card: {}", entry.id));
                    }
                }
            }
            Err(e) => {
                report.add_error(&format!("Failed to read structure: {}", e));
            }
        }
        
        // 6. 验证资源完整性（可选）
        // ...
        
        Ok(report)
    }
}

/// 验证报告
#[derive(Debug, Default)]
pub struct ValidationReport {
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
}

impl ValidationReport {
    pub fn new() -> Self {
        Default::default()
    }
    
    pub fn add_error(&mut self, error: &str) {
        self.errors.push(error.to_string());
    }
    
    pub fn add_warning(&mut self, warning: &str) {
        self.warnings.push(warning.to_string());
    }
    
    pub fn is_valid(&self) -> bool {
        self.errors.is_empty()
    }
    
    pub fn has_errors(&self) -> bool {
        !self.errors.is_empty()
    }
    
    pub fn has_warnings(&self) -> bool {
        !self.warnings.is_empty()
    }
}
```

## 4.7 性能优化

### 4.7.1 缓存识别结果

```rust
/// 文件类型缓存
pub struct FileTypeCache {
    /// 文件路径 -> (文件类型, 修改时间)
    cache: Arc<Mutex<LruCache<PathBuf, (FileType, SystemTime)>>>,
}

impl FileTypeCache {
    /// 获取缓存的文件类型
    pub async fn get(&self, file_path: &Path) -> Option<FileType> {
        let metadata = tokio::fs::metadata(file_path).await.ok()?;
        let modified = metadata.modified().ok()?;
        
        let mut cache = self.cache.lock().await;
        
        if let Some((file_type, cached_modified)) = cache.get(file_path) {
            // 检查文件是否被修改
            if *cached_modified == modified {
                return Some(file_type.clone());
            }
        }
        
        None
    }
    
    /// 保存到缓存
    pub async fn put(&self, file_path: PathBuf, file_type: FileType) -> Result<()> {
        let metadata = tokio::fs::metadata(&file_path).await?;
        let modified = metadata.modified()?;
        
        let mut cache = self.cache.lock().await;
        cache.put(file_path, (file_type, modified));
        
        Ok(())
    }
}
```

### 4.7.2 异步并行处理

```rust
impl FileRecognizer {
    /// 批量识别文件类型
    pub async fn recognize_batch(&self, file_paths: &[PathBuf]) -> Vec<Result<FileType>> {
        // 并发处理所有文件
        let tasks: Vec<_> = file_paths
            .iter()
            .map(|path| self.recognize(path))
            .collect();
        
        futures::future::join_all(tasks).await
    }
}
```

## 4.8 配置

```yaml
# file_recognizer.yaml

file_recognizer:
  # 是否启用文件类型缓存
  enable_cache: true
  
  # 缓存大小
  cache_size: 1000
  
  # 魔数检测时读取的字节数
  magic_number_bytes: 16
  
  # 是否严格验证文件类型（魔数验证）
  strict_validation: true
  
  # 卡片文件验证选项
  card_validation:
    # 是否验证资源完整性
    check_resources: true
    
    # 是否验证封面
    check_cover: false
```

---

文件识别系统是用户与内核交互的第一步，需要快速准确。推荐使用成熟的开源库（如infer）来提高识别准确率。
