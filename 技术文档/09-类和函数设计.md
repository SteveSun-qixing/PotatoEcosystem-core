# 09-类和函数设计

## 9.1 核心类设计

### 9.1.1 ChipsCore类

```rust
/// 薯片内核主类
pub struct ChipsCore {
    /// 路由系统
    router: Arc<Router>,
    
    /// 模块管理器
    module_manager: Arc<ModuleManager>,
    
    /// 资源管理器
    resource_manager: Arc<ResourceManager>,
    
    /// 文件识别器
    file_recognizer: Arc<FileRecognizer>,
    
    /// 配置
    config: Arc<RwLock<CoreConfig>>,
    
    /// 日志记录器
    logger: Arc<Logger>,
    
    /// 内核状态
    state: Arc<RwLock<CoreState>>,
}

impl ChipsCore {
    /// 初始化内核
    pub async fn initialize(config: CoreConfig) -> Result<Self> {
        // 1. 初始化日志系统
        let logger = Logger::initialize(&config.log_level)?;
        
        // 2. 创建事件总线
        let event_bus = Arc::new(EventBus::new());
        
        // 3. 初始化模块管理器
        let module_manager = Arc::new(
            ModuleManager::new(config.module_dirs.clone(), Arc::clone(&event_bus))
        );
        
        // 4. 初始化路由系统
        let router = Arc::new(
            Router::new(Arc::clone(&module_manager), Arc::clone(&event_bus))
        );
        
        // 5. 初始化资源管理器
        let resource_manager = Arc::new(ResourceManager::new());
        
        // 6. 初始化文件识别器
        let file_recognizer = Arc::new(
            FileRecognizer::new(Arc::clone(&router), Arc::clone(&resource_manager))
        );
        
        Ok(Self {
            router,
            module_manager,
            resource_manager,
            file_recognizer,
            config: Arc::new(RwLock::new(config)),
            logger: Arc::new(logger),
            state: Arc::new(RwLock::new(CoreState::Initialized)),
        })
    }
    
    /// 启动内核
    pub async fn start(&self) -> Result<()> {
        let mut state = self.state.write().await;
        if *state != CoreState::Initialized {
            return Err(Error::InvalidState);
        }
        
        // 启动各子系统
        self.router.start().await?;
        self.module_manager.start().await?;
        
        *state = CoreState::Running;
        info!("Chips Core started");
        
        Ok(())
    }
    
    /// 停止内核
    pub async fn stop(&self) -> Result<()> {
        let mut state = self.state.write().await;
        if *state != CoreState::Running {
            return Err(Error::InvalidState);
        }
        
        // 停止各子系统
        self.module_manager.stop().await?;
        self.router.stop().await?;
        
        *state = CoreState::Stopped;
        info!("Chips Core stopped");
        
        Ok(())
    }
}
```

### 9.1.2 Router类

```rust
pub struct Router {
    /// 路由表
    route_table: Arc<RouteTable>,
    
    /// 请求队列
    request_queue: Arc<RequestQueue>,
    
    /// 请求处理器
    processor: Arc<RouteProcessor>,
    
    /// 事件总线
    event_bus: Arc<EventBus>,
    
    /// 统计信息
    stats: Arc<RouteStats>,
}

impl Router {
    /// 发送路由请求
    pub async fn route(&self, request: RouteRequest) -> RouteResponse {
        let start_time = Instant::now();
        let request_id = request.request_id.clone();
        
        // 验证请求
        if let Err(e) = request.validate() {
            return RouteResponse::error(
                &request_id,
                400,
                ErrorInfo::from(e),
                0,
            );
        }
        
        // 查找目标模块
        let target = match self.find_target_module(&request).await {
            Ok(t) => t,
            Err(e) => {
                return RouteResponse::error(
                    &request_id,
                    404,
                    ErrorInfo::from(e),
                    start_time.elapsed().as_millis() as u64,
                );
            }
        };
        
        // 入队
        let (tx, rx) = oneshot::channel();
        let item = QueueItem {
            request: request.clone(),
            target_module: target,
            response_tx: tx,
            enqueued_at: Instant::now(),
        };
        
        if let Err(e) = self.request_queue.enqueue(item).await {
            return RouteResponse::error(
                &request_id,
                500,
                ErrorInfo::from(e),
                start_time.elapsed().as_millis() as u64,
            );
        }
        
        // 等待响应（带超时）
        match timeout(Duration::from_millis(request.timeout_ms), rx).await {
            Ok(Ok(response)) => {
                self.stats.record_request(true, response.elapsed_ms);
                response
            }
            _ => {
                self.stats.record_request(false, start_time.elapsed().as_millis() as u64);
                RouteResponse::error(
                    &request_id,
                    408,
                    ErrorInfo::new("TIMEOUT", "Request timeout"),
                    start_time.elapsed().as_millis() as u64,
                )
            }
        }
    }
    
    /// 查找目标模块
    async fn find_target_module(&self, request: &RouteRequest) -> Result<String> {
        self.route_table.find_route(request)
            .ok_or_else(|| Error::NoRouteFound(request.action.clone()))
            .map(|entry| entry.module_id.clone())
    }
}
```

### 9.1.3 ModuleManager类

```rust
pub struct ModuleManager {
    /// 模块注册表
    registry: Arc<ModuleRegistry>,
    
    /// 模块加载器
    loader: Arc<ModuleLoader>,
    
    /// 依赖解析器
    dependency_resolver: Arc<DependencyResolver>,
    
    /// 生命周期管理器
    lifecycle_manager: Arc<LifecycleManager>,
}

impl ModuleManager {
    /// 加载模块
    pub async fn load(&self, module_id: &str) -> Result<()> {
        // 1. 检查是否已加载
        if let Some(state) = self.registry.get_state(module_id).await {
            if state == ModuleState::Running {
                return Err(Error::ModuleAlreadyLoaded(module_id.to_string()));
            }
        }
        
        // 2. 解析依赖
        let dependencies = self.dependency_resolver.resolve(module_id).await?;
        
        // 3. 加载依赖
        for dep_id in &dependencies {
            if dep_id != module_id {
                self.load(dep_id).await?;
            }
        }
        
        // 4. 加载模块
        let instance = self.loader.load(module_id).await?;
        
        // 5. 初始化
        self.lifecycle_manager.initialize(&instance).await?;
        
        // 6. 更新状态
        self.registry.set_state(module_id, ModuleState::Running).await?;
        
        Ok(())
    }
    
    /// 卸载模块
    pub async fn unload(&self, module_id: &str) -> Result<()> {
        // 1. 检查依赖
        let dependents = self.registry.get_dependency_graph()
            .await
            .get_dependents(module_id);
        
        if !dependents.is_empty() {
            return Err(Error::ModuleHasDependents {
                module: module_id.to_string(),
                dependents,
            });
        }
        
        // 2. 清理
        self.lifecycle_manager.cleanup(module_id).await?;
        
        // 3. 卸载
        self.loader.unload(module_id).await?;
        
        // 4. 更新状态
        self.registry.set_state(module_id, ModuleState::Unloaded).await?;
        
        Ok(())
    }
}
```

## 9.2 关键函数设计

### 9.2.1 路由查找函数

```rust
impl RouteTable {
    /// 查找路由
    pub fn find_route(&self, request: &RouteRequest) -> Option<&RouteEntry> {
        // 1. 明确指定目标
        if let Some(ref target) = request.target {
            return self.find_by_module_id(target);
        }
        
        // 2. 自定义路由
        for custom_route in &self.custom_routes {
            if custom_route.pattern.is_match(&request.action) {
                return Some(&custom_route.entry);
            }
        }
        
        // 3. Action路由
        if let Some(entry) = self.action_routes.get(&request.action) {
            return Some(self.find_best_entry(entry));
        }
        
        // 4. 资源类型路由
        if let Some(ref resource_type) = request.resource_type {
            if let Some(entry) = self.resource_routes.get(resource_type) {
                return Some(self.find_best_entry(entry));
            }
        }
        
        // 5. 默认路由
        self.default_route.as_ref()
    }
    
    /// 从多个条目中选择最佳的
    fn find_best_entry<'a>(&self, entries: &'a [RouteEntry]) -> &'a RouteEntry {
        entries.iter()
            .filter(|e| e.enabled)
            .max_by_key(|e| e.priority)
            .expect("No enabled entries")
    }
}
```

### 9.2.2 依赖解析函数

```rust
impl DependencyResolver {
    /// 递归解析依赖
    async fn resolve_recursive(
        &self,
        module_id: &str,
        resolved: &mut Vec<String>,
        visited: &mut HashSet<String>,
    ) -> Result<()> {
        // 检测循环依赖
        if visited.contains(module_id) {
            return Ok(());
        }
        
        visited.insert(module_id.to_string());
        
        // 获取模块信息
        let module_info = self.registry.get_module(module_id).await
            .ok_or_else(|| Error::ModuleNotFound(module_id.to_string()))?;
        
        // 解析每个依赖
        for dep in &module_info.metadata.dependencies {
            // 检查版本兼容性
            let dep_module = self.registry.get_module(&dep.id).await
                .ok_or_else(|| Error::DependencyNotFound(dep.id.clone()))?;
            
            if !dep.version.matches(&dep_module.metadata.version) {
                return Err(Error::VersionMismatch {
                    module: dep.id.clone(),
                    required: dep.version.to_string(),
                    found: dep_module.metadata.version.to_string(),
                });
            }
            
            // 递归解析
            self.resolve_recursive(&dep.id, resolved, visited).await?;
        }
        
        // 后序遍历：依赖在前，自己在后
        resolved.push(module_id.to_string());
        
        Ok(())
    }
}
```

### 9.2.3 文件类型识别函数

```rust
impl FileRecognizer {
    /// 识别文件类型
    pub async fn recognize(&self, file_path: &Path) -> Result<FileType> {
        // 1. 检查缓存
        if let Some(cached) = self.cache.get(file_path).await {
            return Ok(cached);
        }
        
        // 2. 扩展名检测
        let ext_result = self.extension_detector.detect(file_path)?;
        
        // 3. 魔数检测（验证）
        let magic_result = self.magic_detector.detect(file_path).await?;
        
        // 4. 确定最终类型
        let file_type = match (ext_result, magic_result) {
            (Some(ext_type), Some(magic_type)) => {
                if ext_type == magic_type {
                    ext_type
                } else {
                    // 魔数优先
                    warn!("Extension and magic number mismatch for {:?}", file_path);
                    magic_type
                }
            }
            (Some(ext_type), None) => ext_type,
            (None, Some(magic_type)) => magic_type,
            (None, None) => FileType::Unknown,
        };
        
        // 5. 保存到缓存
        self.cache.put(file_path.to_path_buf(), file_type.clone()).await?;
        
        Ok(file_type)
    }
}
```

### 9.2.4 资源读取函数

```rust
impl ResourceManager {
    /// 读取资源
    pub async fn read(&self, resource_path: &str) -> Result<Vec<u8>> {
        // 1. 解析路径
        let resolved = self.path_resolver.resolve(resource_path).await?;
        
        // 2. 检查缓存
        if resolved.cacheable {
            if let Some(cached) = self.cache_manager.get(&resolved.url).await {
                return Ok(cached);
            }
        }
        
        // 3. 获取提供者
        let provider = self.get_provider(&resolved.scheme)?;
        
        // 4. 读取资源
        let data = provider.read(&resolved).await?;
        
        // 5. 保存到缓存
        if resolved.cacheable {
            self.cache_manager.put(&resolved.url, &data).await?;
        }
        
        Ok(data)
    }
    
    /// 获取资源提供者
    fn get_provider(&self, scheme: &str) -> Result<&dyn ResourceProvider> {
        self.providers.get(scheme)
            .map(|p| p.as_ref())
            .ok_or_else(|| Error::UnsupportedScheme(scheme.to_string()))
    }
}
```

## 9.3 辅助函数设计

### 9.3.1 ID生成

```rust
/// ID生成器
pub struct IdGenerator;

impl IdGenerator {
    /// 生成10位62进制ID
    pub fn generate_card_id() -> String {
        use rand::Rng;
        
        const CHARS: &[u8] = b"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let mut rng = rand::thread_rng();
        
        (0..10)
            .map(|_| {
                let idx = rng.gen_range(0..CHARS.len());
                CHARS[idx] as char
            })
            .collect()
    }
    
    /// 生成UUID
    pub fn generate_uuid() -> String {
        uuid::Uuid::new_v4().to_string()
    }
}
```

### 9.3.2 错误转换

```rust
/// 错误信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorInfo {
    pub code: String,
    pub message: String,
    pub details: Option<String>,
    pub stack_trace: Option<String>,
}

impl ErrorInfo {
    pub fn new(code: &str, message: &str) -> Self {
        Self {
            code: code.to_string(),
            message: message.to_string(),
            details: None,
            stack_trace: None,
        }
    }
}

impl From<Error> for ErrorInfo {
    fn from(error: Error) -> Self {
        ErrorInfo {
            code: error.code(),
            message: error.to_string(),
            details: error.details(),
            stack_trace: error.stack_trace(),
        }
    }
}
```

### 9.3.3 日志宏

```rust
/// 日志宏（基于tracing）
pub use tracing::{debug, info, warn, error};

/// 带上下文的日志
#[macro_export]
macro_rules! log_with_context {
    ($level:ident, $($key:ident = $value:expr),*, $msg:expr) => {
        $level!(
            $($key = %$value,)*
            $msg
        );
    };
}

// 使用示例：
// log_with_context!(info, request_id = req_id, module = "router", "Processing request");
```

## 9.4 函数命名约定

### 9.4.1 查询函数

- `get_*`: 获取单个对象，可能返回None
- `find_*`: 查找，可能返回None
- `list_*`: 获取列表
- `exists`: 检查存在性

```rust
impl ModuleRegistry {
    pub async fn get_module(&self, id: &str) -> Option<ModuleInfo>;
    pub async fn find_modules(&self, predicate: impl Fn(&ModuleInfo) -> bool) -> Vec<ModuleInfo>;
    pub async fn list_modules(&self) -> Vec<ModuleInfo>;
    pub async fn exists(&self, id: &str) -> bool;
}
```

### 9.4.2 修改函数

- `set_*`: 设置值
- `add_*`: 添加元素
- `remove_*`: 移除元素
- `update_*`: 更新
- `delete_*`: 删除

```rust
impl RouteTable {
    pub async fn set_default_route(&mut self, entry: RouteEntry);
    pub async fn add_route(&mut self, action: &str, entry: RouteEntry);
    pub async fn remove_route(&mut self, action: &str, module_id: &str);
    pub async fn update_priority(&mut self, action: &str, priority: i32);
}
```

### 9.4.3 异步函数

- 异步操作使用`async fn`
- 名称不需要特殊后缀

```rust
impl ResourceManager {
    pub async fn read(&self, path: &str) -> Result<Vec<u8>>;  // 正确
    // 不要：pub async fn read_async(&self, path: &str)
}
```

## 9.5 错误处理模式

### 9.5.1 使用Result

```rust
pub async fn load_module(&self, id: &str) -> Result<()> {
    let module_info = self.registry.get_module(id).await
        .ok_or_else(|| Error::ModuleNotFound(id.to_string()))?;
    
    // ...
    
    Ok(())
}
```

### 9.5.2 错误传播

```rust
pub async fn process_file(&self, path: &Path) -> Result<()> {
    let file_type = self.recognize(path).await?;  // ? 自动传播错误
    let handler = self.find_handler(&file_type)?;
    handler.process(path).await?;
    Ok(())
}
```

### 9.5.3 错误转换

```rust
impl From<std::io::Error> for Error {
    fn from(err: std::io::Error) -> Self {
        Error::IoError(err.to_string())
    }
}
```

## 9.6 性能优化技巧

### 9.6.1 避免不必要的克隆

```rust
// 不好
pub fn process(&self, data: String) {
    // ...
}

// 好
pub fn process(&self, data: &str) {
    // ...
}
```

### 9.6.2 使用引用计数

```rust
// 大对象用Arc共享
pub struct Router {
    route_table: Arc<RouteTable>,  // 共享所有权
}
```

### 9.6.3 延迟计算

```rust
// 使用闭包延迟计算
pub fn log_if_debug(&self, msg: impl FnOnce() -> String) {
    if self.debug {
        debug!("{}", msg());
    }
}

// 使用：只有debug模式才执行msg()
router.log_if_debug(|| format!("Complex computation: {}", expensive_operation()));
```

---

良好的类和函数设计是代码可读性和可维护性的基础。遵循一致的命名和错误处理模式能显著提升代码质量。
