# 10-开发指南

## 10.1 开发环境搭建

### 10.1.1 安装Rust

```bash
# 安装Rust（推荐使用rustup）
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 验证安装
rustc --version
cargo --version

# 安装nightly版本（可选，用于某些高级特性）
rustup install nightly
```

### 10.1.2 克隆项目

```bash
git clone https://github.com/chips/core.git
cd core

# 安装依赖
cargo build
```

### 10.1.3 IDE配置

**推荐使用VSCode + rust-analyzer**：

```json
// .vscode/settings.json
{
  "rust-analyzer.cargo.features": ["full"],
  "rust-analyzer.checkOnSave.command": "clippy",
  "editor.formatOnSave": true
}
```

**推荐的VSCode扩展**：
- rust-analyzer
- CodeLLDB (调试)
- Better TOML
- Even Better TOML

## 10.2 构建和运行

### 10.2.1 构建项目

```bash
# 开发模式构建
cargo build

# 发布模式构建
cargo build --release

# 构建特定feature
cargo build --features http-api,cli
```

### 10.2.2 运行测试

```bash
# 运行所有测试
cargo test

# 运行特定模块的测试
cargo test router

# 运行单个测试
cargo test test_route_request

# 显示输出
cargo test -- --nocapture

# 运行集成测试
cargo test --test router_test
```

### 10.2.3 运行示例

```bash
# 运行示例
cargo run --example basic_usage

# 带参数运行
cargo run --example basic_usage -- --debug
```

### 10.2.4 运行内核

```bash
# 开发模式运行
cargo run -- start --config config.yaml --debug

# 发布模式运行
cargo run --release -- start
```

## 10.3 开发工作流

### 10.3.1 创建新功能

```bash
# 1. 创建新分支
git checkout -b feature/new-feature

# 2. 编写代码

# 3. 运行测试
cargo test

# 4. 检查代码风格
cargo fmt --check
cargo clippy -- -D warnings

# 5. 提交
git add .
git commit -m "Add new feature"

# 6. 推送
git push origin feature/new-feature

# 7. 创建PR
```

### 10.3.2 代码格式化

```bash
# 格式化所有代码
cargo fmt

# 检查格式
cargo fmt -- --check
```

### 10.3.3 代码检查

```bash
# 运行Clippy（Rust的lint工具）
cargo clippy

# 严格模式
cargo clippy -- -D warnings

# 修复自动可修复的问题
cargo clippy --fix
```

### 10.3.4 性能测试

```bash
# 运行基准测试
cargo bench

# 运行特定基准
cargo bench route_bench
```

## 10.4 添加新模块

### 10.4.1 创建模块文件

```bash
# 在src/目录下创建新模块
mkdir src/new_module
touch src/new_module/mod.rs
touch src/new_module/implementation.rs
```

### 10.4.2 模块模板

```rust
// src/new_module/mod.rs

//! 新模块的文档
//! 
//! 这个模块提供...

mod implementation;

pub use implementation::NewComponent;

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_new_component() {
        // 测试代码
    }
}
```

```rust
// src/new_module/implementation.rs

use crate::utils::error::Result;

/// 新组件
pub struct NewComponent {
    // 字段
}

impl NewComponent {
    /// 创建新实例
    pub fn new() -> Self {
        Self {
            // 初始化
        }
    }
    
    /// 主要功能
    pub fn do_something(&self) -> Result<()> {
        // 实现
        Ok(())
    }
}
```

### 10.4.3 注册模块

```rust
// src/lib.rs

pub mod new_module;

pub use new_module::NewComponent;
```

## 10.5 编写测试

### 10.5.1 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_functionality() {
        let component = NewComponent::new();
        assert!(component.do_something().is_ok());
    }
    
    #[tokio::test]
    async fn test_async_functionality() {
        let component = NewComponent::new();
        let result = component.async_operation().await;
        assert!(result.is_ok());
    }
    
    #[test]
    #[should_panic(expected = "expected error message")]
    fn test_error_case() {
        let component = NewComponent::new();
        component.operation_that_should_fail().unwrap();
    }
}
```

### 10.5.2 集成测试

```rust
// tests/integration_test.rs

use chips_core::*;

#[tokio::test]
async fn test_full_workflow() {
    // 初始化
    let config = CoreConfig::default();
    let core = ChipsCore::initialize(config).await.unwrap();
    
    // 启动
    core.start().await.unwrap();
    
    // 测试功能
    // ...
    
    // 停止
    core.stop().await.unwrap();
}
```

### 10.5.3 Mock测试

```rust
use mockall::*;

#[automock]
trait ResourceProvider {
    async fn read(&self, path: &str) -> Result<Vec<u8>>;
}

#[tokio::test]
async fn test_with_mock() {
    let mut mock_provider = MockResourceProvider::new();
    
    mock_provider
        .expect_read()
        .with(eq("test.txt"))
        .times(1)
        .returning(|_| Ok(vec![1, 2, 3]));
    
    let result = mock_provider.read("test.txt").await.unwrap();
    assert_eq!(result, vec![1, 2, 3]);
}
```

## 10.6 调试技巧

### 10.6.1 使用println调试

```rust
pub fn debug_function(&self) {
    println!("Debug: value = {:?}", self.value);
    
    // 或使用dbg!宏
    dbg!(&self.value);
}
```

### 10.6.2 使用tracing调试

```rust
use tracing::{debug, info, instrument};

#[instrument]
pub async fn traced_function(&self, param: &str) -> Result<()> {
    debug!("Function called with param: {}", param);
    
    // 自动记录函数入口、出口和参数
    // ...
    
    info!("Operation completed");
    Ok(())
}
```

### 10.6.3 VSCode调试配置

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug chips-core",
      "cargo": {
        "args": [
          "build",
          "--bin=chips-core",
          "--package=chips-core"
        ],
        "filter": {
          "name": "chips-core",
          "kind": "bin"
        }
      },
      "args": ["start", "--debug"],
      "cwd": "${workspaceFolder}"
    },
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug unit tests",
      "cargo": {
        "args": [
          "test",
          "--no-run",
          "--lib"
        ]
      },
      "args": [],
      "cwd": "${workspaceFolder}"
    }
  ]
}
```

## 10.7 性能分析

### 10.7.1 使用criterion进行基准测试

```rust
// benches/my_bench.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion};
use chips_core::*;

fn benchmark_route(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let router = rt.block_on(async {
        Router::new()
    });
    
    c.bench_function("route_request", |b| {
        b.to_async(&rt).iter(|| async {
            let request = RouteRequest::new("sender", "action", json!({}));
            router.route(black_box(request)).await
        });
    });
}

criterion_group!(benches, benchmark_route);
criterion_main!(benches);
```

### 10.7.2 使用flamegraph生成火焰图

```bash
# 安装工具
cargo install flamegraph

# 生成火焰图
cargo flamegraph --bin chips-core -- start

# 结果保存在flamegraph.svg
```

### 10.7.3 使用perf分析（Linux）

```bash
# 构建带调试符号的release版本
cargo build --release

# 运行perf
perf record -g ./target/release/chips-core start
perf report
```

## 10.8 文档编写

### 10.8.1 代码文档

```rust
/// 路由请求
/// 
/// 这个结构体表示一个路由请求，包含所有必要的信息。
/// 
/// # 示例
/// 
/// ```
/// use chips_core::RouteRequest;
/// use serde_json::json;
/// 
/// let request = RouteRequest::new("my-module", "doSomething", json!({
///     "param1": "value1"
/// }));
/// ```
pub struct RouteRequest {
    /// 请求ID
    pub request_id: String,
    
    /// 发送者模块ID
    pub sender: String,
    
    // ...
}

impl RouteRequest {
    /// 创建新的路由请求
    /// 
    /// # 参数
    /// 
    /// * `sender` - 发送者模块ID
    /// * `action` - 请求的动作
    /// * `params` - 请求参数
    /// 
    /// # 示例
    /// 
    /// ```
    /// # use chips_core::RouteRequest;
    /// # use serde_json::json;
    /// let request = RouteRequest::new("sender", "action", json!({}));
    /// ```
    pub fn new(sender: &str, action: &str, params: Value) -> Self {
        // ...
    }
}
```

### 10.8.2 生成文档

```bash
# 生成文档
cargo doc

# 生成并打开文档
cargo doc --open

# 包含私有项
cargo doc --document-private-items
```

## 10.9 发布流程

### 10.9.1 版本号管理

```toml
# Cargo.toml
[package]
version = "1.2.3"  # 主版本.次版本.修订号
```

遵循语义化版本规范：
- 主版本号：不兼容的API变更
- 次版本号：向后兼容的功能新增
- 修订号：向后兼容的问题修正

### 10.9.2 发布检查清单

- [ ] 所有测试通过
- [ ] 代码格式化
- [ ] Clippy检查通过
- [ ] 文档更新
- [ ] CHANGELOG更新
- [ ] 版本号更新
- [ ] 创建git tag

```bash
# 发布前检查
cargo test
cargo fmt -- --check
cargo clippy -- -D warnings
cargo doc

# 创建tag
git tag v1.2.3
git push origin v1.2.3

# 发布到crates.io
cargo publish
```

## 10.10 常见问题

### 10.10.1 编译错误

**问题**：`error: linking with cc failed`

**解决**：安装C编译器
```bash
# macOS
xcode-select --install

# Linux
sudo apt-get install build-essential

# Windows
# 安装Visual Studio Build Tools
```

### 10.10.2 依赖冲突

**问题**：依赖版本冲突

**解决**：
```bash
# 更新依赖
cargo update

# 查看依赖树
cargo tree

# 修复特定依赖
cargo update -p specific-crate
```

### 10.10.3 测试失败

**问题**：异步测试超时

**解决**：
```rust
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_with_timeout() {
    tokio::time::timeout(Duration::from_secs(5), async {
        // 测试代码
    }).await.unwrap();
}
```

## 10.11 最佳实践

### 10.11.1 代码组织

- 每个文件不超过500行
- 每个函数不超过50行
- 相关功能组织在同一模块
- 使用`mod.rs`作为模块入口

### 10.11.2 错误处理

- 使用`Result<T, Error>`而不是`panic!`
- 提供清晰的错误信息
- 使用`?`运算符传播错误
- 不要忽略错误（避免`let _ = ...`）

### 10.11.3 性能优化

- 避免不必要的克隆
- 使用`Arc`共享大对象
- 使用`&str`而不是`String`作为参数
- 延迟计算（使用闭包）
- 使用`#[inline]`标记热点函数

### 10.11.4 并发安全

- 优先使用消息传递而不是共享状态
- 使用`Arc<RwLock<T>>`进行共享状态
- 避免死锁（获取锁的顺序一致）
- 使用异步而不是线程

---

## 10.12 开发资源

**官方文档**：
- Rust Book: https://doc.rust-lang.org/book/
- Async Book: https://rust-lang.github.io/async-book/
- Tokio文档: https://tokio.rs/

**推荐阅读**：
- "Programming Rust" by Jim Blandy
- "Rust for Rustaceans" by Jon Gjengset

**社区资源**：
- Rust Users Forum: https://users.rust-lang.org/
- r/rust on Reddit
- Rust Discord

---

遵循本开发指南可以确保代码质量和团队协作效率。随着项目发展，持续更新和完善开发指南。
