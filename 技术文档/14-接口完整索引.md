# 14-接口完整索引

## 1. 核心接口(Trait)

### 1.1 Core Trait

**位置**: `src/core/core.rs`

**作用**: 内核接口,定义内核基本功能

```rust
#[async_trait]
pub trait Core {
    /// 初始化内核
    async fn initialize(config: CoreConfig) -> Result<Self> where Self: Sized;
    
    /// 启动内核
    async fn start(&self) -> Result<()>;
    
    /// 停止内核
    async fn stop(&self) -> Result<()>;
    
    /// 获取路由系统
    fn router(&self) -> &Router;
    
    /// 获取模块管理器
    fn module_manager(&self) -> &ModuleManager;
    
    /// 获取资源管理器
    fn resource_manager(&self) -> &ResourceManager;
    
    /// 获取文件识别器
    fn file_recognizer(&self) -> &FileRecognizer;
}
```

**实现类**
- `ChipsCore`

**使用示例**
```rust
let core = ChipsCore::initialize(config).await?;
core.start().await?;
let router = core.router();
```

---

## 2. 路由接口

### 2.1 Router Trait

**位置**: `src/router/router.rs`

**作用**: 路由器接口,定义路由功能

```rust
#[async_trait]
pub trait Router: Send + Sync {
    /// 发送路由请求
    async fn route(&self, request: RouteRequest) -> RouteResponse;
    
    /// 批量路由
    async fn route_batch(&self, requests: Vec<RouteRequest>) -> Vec<RouteResponse>;
    
    /// 订阅事件
    async fn subscribe(&self, event_type: &str, subscriber: &str) -> Result<()>;
    
    /// 取消订阅
    async fn unsubscribe(&self, event_type: &str, subscriber: &str) -> Result<()>;
    
    /// 广播事件
    async fn broadcast(&self, event: Event);
    
    /// 注册路由规则
    async fn register_route(&self, action: &str, module_id: &str, priority: i32) -> Result<()>;
    
    /// 移除路由规则
    async fn unregister_route(&self, action: &str, module_id: &str) -> Result<()>;
}
```

**实现类**
- `RouterImpl`

**使用示例**
```rust
let response = router.route(request).await;
router.subscribe("file.imported", "my-module").await?;
```

---

## 3. 模块接口

### 3.1 Module Trait

**位置**: `src/module/module.rs`

**作用**: 模块接口,定义模块生命周期

```rust
#[async_trait]
pub trait Module: Send + Sync {
    /// 模块初始化
    async fn on_init(&mut self) -> Result<()> {
        Ok(())
    }
    
    /// 模块启动
    async fn on_start(&mut self) -> Result<()> {
        Ok(())
    }
    
    /// 模块停止
    async fn on_stop(&mut self) -> Result<()> {
        Ok(())
    }
    
    /// 模块清理
    async fn on_cleanup(&mut self) -> Result<()> {
        Ok(())
    }
    
    /// 健康检查
    async fn on_health_check(&self) -> Result<HealthStatus> {
        Ok(HealthStatus::Healthy)
    }
    
    /// 处理路由请求
    async fn handle_request(&mut self, request: RouteRequest) -> RouteResponse;
    
    /// 处理事件
    async fn handle_event(&mut self, event: Event) -> Result<()> {
        Ok(())
    }
}
```

**实现示例**
```rust
pub struct MyModule {
    context: ModuleContext,
}

#[async_trait]
impl Module for MyModule {
    async fn on_init(&mut self) -> Result<()> {
        // 初始化逻辑
        self.context.router.register_route("my.action", &self.context.module_id, 100).await?;
        Ok(())
    }
    
    async fn handle_request(&mut self, request: RouteRequest) -> RouteResponse {
        // 处理请求
        match request.action.as_str() {
            "my.action" => {
                RouteResponse::success(&request.request_id, json!({"ok": true}), 0)
            }
            _ => RouteResponse::error(
                &request.request_id,
                404,
                ErrorInfo::new("NO_ROUTE_FOUND", "Unknown action"),
                0
            ),
        }
    }
}
```

---

### 3.2 ModuleManager Trait

**位置**: `src/module/manager.rs`

**作用**: 模块管理器接口

```rust
#[async_trait]
pub trait ModuleManager: Send + Sync {
    /// 扫描模块
    async fn scan(&self) -> Result<Vec<String>>;
    
    /// 注册模块
    async fn register(&self, module_path: &Path) -> Result<String>;
    
    /// 加载模块
    async fn load(&self, module_id: &str) -> Result<()>;
    
    /// 卸载模块
    async fn unload(&self, module_id: &str) -> Result<()>;
    
    /// 获取模块信息
    async fn get_module(&self, module_id: &str) -> Option<ModuleInfo>;
    
    /// 列出所有模块
    async fn list_modules(&self) -> Vec<ModuleInfo>;
    
    /// 获取模块状态
    async fn get_state(&self, module_id: &str) -> Option<ModuleState>;
}
```

**实现类**
- `ModuleManagerImpl`

---

## 4. 资源接口

### 4.1 ResourceProvider Trait

**位置**: `src/resource/provider.rs`

**作用**: 资源提供者接口

```rust
#[async_trait]
pub trait ResourceProvider: Send + Sync {
    /// 读取资源
    async fn read(&self, resolved: &ResolvedPath) -> Result<Vec<u8>>;
    
    /// 写入资源
    async fn write(&self, resolved: &ResolvedPath, data: &[u8]) -> Result<()>;
    
    /// 检查资源是否存在
    async fn exists(&self, resolved: &ResolvedPath) -> Result<bool>;
    
    /// 获取资源元信息
    async fn metadata(&self, resolved: &ResolvedPath) -> Result<ResourceMetadata>;
    
    /// 删除资源
    async fn delete(&self, resolved: &ResolvedPath) -> Result<()>;
    
    /// 列出资源
    async fn list(&self, resolved: &ResolvedPath) -> Result<Vec<String>>;
}
```

**实现类**
- `LocalFileProvider` - 本地文件系统
- `HttpProvider` - HTTP/HTTPS资源
- `WebDAVProvider` - WebDAV协议

**实现示例**
```rust
pub struct LocalFileProvider;

#[async_trait]
impl ResourceProvider for LocalFileProvider {
    async fn read(&self, resolved: &ResolvedPath) -> Result<Vec<u8>> {
        tokio::fs::read(&resolved.path).await
            .map_err(|e| Error::IoError(e.to_string()))
    }
    
    async fn write(&self, resolved: &ResolvedPath, data: &[u8]) -> Result<()> {
        tokio::fs::write(&resolved.path, data).await
            .map_err(|e| Error::IoError(e.to_string()))
    }
    
    async fn exists(&self, resolved: &ResolvedPath) -> Result<bool> {
        Ok(resolved.path.exists())
    }
    
    async fn metadata(&self, resolved: &ResolvedPath) -> Result<ResourceMetadata> {
        let meta = tokio::fs::metadata(&resolved.path).await?;
        Ok(ResourceMetadata {
            size: meta.len(),
            modified: meta.modified().ok().map(|t| DateTime::from(t)),
            mime_type: infer::get_from_path(&resolved.path).ok()
                .map(|t| t.mime_type().to_string()),
            is_directory: meta.is_dir(),
        })
    }
    
    // ... 其他方法实现
}
```

---

### 4.2 ResourceManager Trait

**位置**: `src/resource/manager.rs`

**作用**: 资源管理器接口

```rust
#[async_trait]
pub trait ResourceManager: Send + Sync {
    /// 读取资源
    async fn read(&self, resource_path: &str) -> Result<Vec<u8>>;
    
    /// 读取资源为字符串
    async fn read_to_string(&self, resource_path: &str) -> Result<String>;
    
    /// 写入资源
    async fn write(&self, resource_path: &str, data: &[u8]) -> Result<()>;
    
    /// 检查资源是否存在
    async fn exists(&self, resource_path: &str) -> Result<bool>;
    
    /// 获取资源元信息
    async fn metadata(&self, resource_path: &str) -> Result<ResourceMetadata>;
    
    /// 删除资源
    async fn delete(&self, resource_path: &str) -> Result<()>;
    
    /// 复制资源
    async fn copy(&self, from: &str, to: &str) -> Result<()>;
    
    /// 移动资源
    async fn move_resource(&self, from: &str, to: &str) -> Result<()>;
}
```

**实现类**
- `ResourceManagerImpl`

---

## 5. 文件识别接口

### 5.1 FileDetector Trait

**位置**: `src/file/detector/mod.rs`

**作用**: 文件检测器接口

```rust
#[async_trait]
pub trait FileDetector: Send + Sync {
    /// 检测文件类型
    async fn detect(&self, file_path: &Path) -> Result<Option<FileType>>;
    
    /// 检测器名称
    fn name(&self) -> &str;
    
    /// 检测器优先级
    fn priority(&self) -> i32 {
        0
    }
}
```

**实现类**
- `ExtensionDetector` - 扩展名检测
- `MagicNumberDetector` - 魔数检测
- `MimeTypeDetector` - MIME类型检测

**实现示例**
```rust
pub struct ExtensionDetector {
    extension_map: HashMap<String, FileType>,
}

#[async_trait]
impl FileDetector for ExtensionDetector {
    async fn detect(&self, file_path: &Path) -> Result<Option<FileType>> {
        if let Some(ext) = file_path.extension() {
            if let Some(ext_str) = ext.to_str() {
                return Ok(self.extension_map.get(ext_str).cloned());
            }
        }
        Ok(None)
    }
    
    fn name(&self) -> &str {
        "ExtensionDetector"
    }
    
    fn priority(&self) -> i32 {
        100 // 高优先级
    }
}
```

---

### 5.2 FileParser Trait

**位置**: `src/file/parser.rs`

**作用**: 文件解析器接口

```rust
#[async_trait]
pub trait FileParser: Send + Sync {
    /// 解析文件
    async fn parse(&self, file_path: &Path) -> Result<ParsedFile>;
    
    /// 验证文件
    async fn validate(&self, file_path: &Path) -> Result<bool>;
    
    /// 支持的文件类型
    fn supported_types(&self) -> Vec<FileType>;
}
```

**实现类**
- `CardParser` - 卡片文件解析器
- `BoxParser` - 箱子文件解析器

---

## 6. 配置接口

### 6.1 ConfigProvider Trait

**位置**: `src/utils/config.rs`

**作用**: 配置提供者接口

```rust
pub trait ConfigProvider: Send + Sync {
    /// 获取配置值
    fn get<T: DeserializeOwned>(&self, key: &str) -> Option<T>;
    
    /// 设置配置值
    fn set<T: Serialize>(&mut self, key: &str, value: T) -> Result<()>;
    
    /// 检查配置键是否存在
    fn has(&self, key: &str) -> bool;
    
    /// 获取所有配置
    fn get_all(&self) -> HashMap<String, Value>;
    
    /// 保存配置
    fn save(&self) -> Result<()>;
    
    /// 重载配置
    fn reload(&mut self) -> Result<()>;
}
```

**实现类**
- `YamlConfigProvider` - YAML配置
- `JsonConfigProvider` - JSON配置
- `TomlConfigProvider` - TOML配置

---

## 7. 日志接口

### 7.1 Logger Trait

**位置**: `src/utils/logger.rs`

**作用**: 日志记录器接口

```rust
pub trait Logger: Send + Sync {
    /// 调试日志
    fn debug(&self, message: &str, context: LogContext);
    
    /// 信息日志
    fn info(&self, message: &str, context: LogContext);
    
    /// 警告日志
    fn warn(&self, message: &str, context: LogContext);
    
    /// 错误日志
    fn error(&self, message: &str, context: LogContext);
    
    /// 致命错误日志
    fn fatal(&self, message: &str, context: LogContext);
}
```

**实现类**
- `TracingLogger` - 基于tracing的日志记录器

---

## 8. 事件接口

### 8.1 EventHandler Trait

**位置**: `src/router/event_bus.rs`

**作用**: 事件处理器接口

```rust
#[async_trait]
pub trait EventHandler: Send + Sync {
    /// 处理事件
    async fn handle(&mut self, event: &Event) -> Result<()>;
    
    /// 支持的事件类型
    fn event_types(&self) -> Vec<String>;
}
```

**实现示例**
```rust
pub struct FileEventHandler;

#[async_trait]
impl EventHandler for FileEventHandler {
    async fn handle(&mut self, event: &Event) -> Result<()> {
        match event.event_type.as_str() {
            "file.imported" => {
                // 处理文件导入事件
                println!("File imported: {:?}", event.data);
            }
            "file.deleted" => {
                // 处理文件删除事件
                println!("File deleted: {:?}", event.data);
            }
            _ => {}
        }
        Ok(())
    }
    
    fn event_types(&self) -> Vec<String> {
        vec![
            "file.imported".to_string(),
            "file.deleted".to_string(),
        ]
    }
}
```

---

## 9. 插件接口

### 9.1 Plugin Trait

**位置**: `src/module/plugin.rs`

**作用**: 插件接口,定义插件基本功能

```rust
#[async_trait]
pub trait Plugin: Send + Sync {
    /// 插件ID
    fn id(&self) -> &str;
    
    /// 插件名称
    fn name(&self) -> &str;
    
    /// 插件版本
    fn version(&self) -> &str;
    
    /// 插件初始化
    async fn initialize(&mut self, context: PluginContext) -> Result<()>;
    
    /// 插件启动
    async fn start(&mut self) -> Result<()>;
    
    /// 插件停止
    async fn stop(&mut self) -> Result<()>;
    
    /// 插件配置
    fn configure(&mut self, config: Value) -> Result<()>;
}
```

**实现示例**
```rust
pub struct MyPlugin {
    id: String,
    name: String,
    version: String,
    context: Option<PluginContext>,
}

#[async_trait]
impl Plugin for MyPlugin {
    fn id(&self) -> &str {
        &self.id
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn version(&self) -> &str {
        &self.version
    }
    
    async fn initialize(&mut self, context: PluginContext) -> Result<()> {
        self.context = Some(context);
        // 初始化逻辑
        Ok(())
    }
    
    async fn start(&mut self) -> Result<()> {
        // 启动逻辑
        Ok(())
    }
    
    async fn stop(&mut self) -> Result<()> {
        // 停止逻辑
        Ok(())
    }
    
    fn configure(&mut self, config: Value) -> Result<()> {
        // 配置逻辑
        Ok(())
    }
}
```

---

## 10. 接口组合关系图

```
                          Core
                            |
           +----------------+----------------+
           |                |                |
        Router        ModuleManager   ResourceManager
           |                |                |
    +------+------+    +----+----+    +------+------+
    |             |    |         |    |             |
EventBus    RouteTable  Module  DependencyResolver  ResourceProvider
                                                     |
                                            +--------+--------+
                                            |        |        |
                                        LocalFile  Http   WebDAV
```

---

## 11. 接口实现规范

### 11.1 命名规范

**Trait命名**
- 使用名词或动词+er
- PascalCase格式
- 例：`Router`, `ResourceProvider`, `FileDetector`

**方法命名**
- 使用动词开头
- snake_case格式
- 例：`read()`, `parse_card()`, `get_module()`

### 11.2 错误处理

所有接口方法应该：
- 使用 `Result<T, Error>` 返回可能失败的操作
- 使用 `Option<T>` 返回可能不存在的值
- 提供清晰的错误信息

```rust
#[async_trait]
pub trait Example {
    // 推荐：返回Result
    async fn operation(&self) -> Result<Data>;
    
    // 推荐：返回Option
    async fn find(&self, id: &str) -> Option<Data>;
    
    // 不推荐：panic
    // async fn must_succeed(&self) -> Data;
}
```

### 11.3 异步规范

- 使用 `#[async_trait]` 宏标记异步trait
- I/O操作必须是异步的
- CPU密集型操作可以是同步的

```rust
#[async_trait]
pub trait AsyncExample {
    // 异步方法（I/O操作）
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>>;
    
    // 同步方法（纯计算）
    fn calculate(&self, x: i32, y: i32) -> i32 {
        x + y
    }
}
```

### 11.4 线程安全

所有trait都应该是线程安全的：

```rust
pub trait Example: Send + Sync {
    // ...
}
```

---

## 12. 完整示例：实现自定义插件

```rust
use chips_core::*;

// 1. 定义插件结构
pub struct CustomPlugin {
    id: String,
    context: Option<ModuleContext>,
}

// 2. 实现Plugin trait
#[async_trait]
impl Plugin for CustomPlugin {
    fn id(&self) -> &str {
        &self.id
    }
    
    fn name(&self) -> &str {
        "Custom Plugin"
    }
    
    fn version(&self) -> &str {
        "1.0.0"
    }
    
    async fn initialize(&mut self, context: PluginContext) -> Result<()> {
        self.context = Some(context);
        Ok(())
    }
    
    async fn start(&mut self) -> Result<()> {
        // 注册路由
        if let Some(ctx) = &self.context {
            ctx.router.register_route(
                "custom.action",
                &self.id,
                100
            ).await?;
        }
        Ok(())
    }
    
    async fn stop(&mut self) -> Result<()> {
        Ok(())
    }
    
    fn configure(&mut self, config: Value) -> Result<()> {
        Ok(())
    }
}

// 3. 实现Module trait
#[async_trait]
impl Module for CustomPlugin {
    async fn handle_request(&mut self, request: RouteRequest) -> RouteResponse {
        match request.action.as_str() {
            "custom.action" => {
                RouteResponse::success(
                    &request.request_id,
                    json!({"message": "Custom action executed"}),
                    0
                )
            }
            _ => RouteResponse::error(
                &request.request_id,
                404,
                ErrorInfo::new("NO_ROUTE_FOUND", "Unknown action"),
                0
            ),
        }
    }
}
```

---

完整的接口索引为插件开发者提供了清晰的扩展点,所有接口都遵循统一的设计规范和最佳实践。
