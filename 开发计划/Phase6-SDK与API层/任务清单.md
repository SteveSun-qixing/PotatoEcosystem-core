# Phase 6: SDK 与 API 层

**阶段状态**: 待开始  
**预计任务数**: 10 个  
**关键依赖**: Phase 1-5 完成

---

## 阶段目标

实现 SDK 接口和各种 API 层，提供友好的开发接口，让开发者能够方便地使用薯片内核的功能。

---

## 任务列表

### Task 6.1: 设计 SDK 公共接口

**任务描述**: 设计 Rust SDK 的公共接口。

**详细步骤**:
1. 创建 `src/api/sdk.rs` 文件
2. 定义 `ChipsCore` 主接口:
   ```rust
   pub struct ChipsCore {
       router: Arc<Router>,
       module_manager: Arc<ModuleManager>,
       event_bus: Arc<EventBus>,
       config_manager: Arc<ConfigManager>,
   }
   ```
3. 设计高层 API:
   - `ChipsCore::new()` - 创建实例
   - `ChipsCore::route()` - 发送路由请求
   - `ChipsCore::subscribe()` - 订阅事件
   - `ChipsCore::publish()` - 发布事件
   - `ChipsCore::load_module()` - 加载模块
   - `ChipsCore::config()` - 配置访问
4. 编写 API 文档注释

**验收标准**:
- [ ] 接口设计合理
- [ ] API 易于使用
- [ ] 文档注释完整
- [ ] 符合 Rust API 设计最佳实践

---

### Task 6.2: 实现 ChipsCore 主结构体

**任务描述**: 实现 ChipsCore 主结构体的完整功能。

**详细步骤**:
1. 实现 `ChipsCore::new()`:
   ```rust
   impl ChipsCore {
       pub async fn new(config: CoreConfig) -> Result<Self> {
           // 初始化日志
           Logger::init(&config.logging)?;
           
           // 初始化配置管理器
           let config_manager = ConfigManager::new(&config.config_path).await?;
           
           // 初始化事件总线
           let event_bus = EventBus::new();
           
           // 初始化路由器
           let router = Router::new(config.router.clone());
           
           // 初始化模块管理器
           let module_manager = ModuleManager::new(
               config.module_dirs.clone(),
               Arc::clone(&router),
               Arc::clone(&event_bus),
           );
           
           Ok(Self {
               router: Arc::new(router),
               module_manager: Arc::new(module_manager),
               event_bus: Arc::new(event_bus),
               config_manager: Arc::new(config_manager),
           })
       }
   }
   ```
2. 实现 `start()` - 启动内核
3. 实现 `shutdown()` - 关闭内核
4. 实现各种便捷方法

**验收标准**:
- [ ] 初始化流程正确
- [ ] 所有组件正确集成
- [ ] 启动和关闭正常
- [ ] 单元测试通过

---

### Task 6.3: 实现便捷路由 API

**任务描述**: 实现便捷的路由 API。

**详细步骤**:
1. 实现 `route()` 方法:
   ```rust
   pub async fn route(&self, request: RouteRequest) -> RouteResponse {
       self.router.route(request).await
   }
   ```
2. 实现 `route_action()` 便捷方法:
   ```rust
   pub async fn route_action(
       &self,
       sender: &str,
       action: &str,
       params: impl Serialize,
   ) -> Result<Value> {
       let request = RouteRequest::new(sender, action, serde_json::to_value(params)?);
       let response = self.route(request).await;
       
       if response.status == StatusCode::OK {
           Ok(response.data.unwrap_or(Value::Null))
       } else {
           Err(Error::from(response.error.unwrap()))
       }
   }
   ```
3. 实现批量路由 API

**验收标准**:
- [ ] 路由 API 正确
- [ ] 便捷方法易用
- [ ] 错误处理完善
- [ ] 单元测试通过

---

### Task 6.4: 实现便捷事件 API

**任务描述**: 实现便捷的事件发布订阅 API。

**详细步骤**:
1. 实现 `subscribe()`:
   ```rust
   pub async fn subscribe<F>(
       &self,
       subscriber_id: &str,
       event_type: &str,
       handler: F,
   ) -> Result<String>
   where
       F: Fn(Event) + Send + Sync + 'static,
   {
       self.event_bus.subscribe(subscriber_id, event_type, None, handler).await
   }
   ```
2. 实现 `publish()`:
   ```rust
   pub async fn publish(&self, event: Event) -> Result<()> {
       self.event_bus.publish(event).await
   }
   ```
3. 实现 `unsubscribe()`

**验收标准**:
- [ ] 事件 API 正确
- [ ] 类型安全
- [ ] 单元测试通过

---

### Task 6.5: 实现 CLI 命令行接口

**任务描述**: 实现命令行接口。

**详细步骤**:
1. 创建 `src/api/cli.rs` 文件
2. 使用 clap 定义命令:
   ```rust
   #[derive(Parser)]
   #[command(name = "chips-core")]
   #[command(about = "Chips Core - 薯片微内核")]
   pub struct Cli {
       /// 配置文件路径
       #[arg(short, long, default_value = "config/default.yaml")]
       pub config: PathBuf,
       
       /// 日志级别
       #[arg(short, long, default_value = "info")]
       pub log_level: String,
       
       #[command(subcommand)]
       pub command: Option<Commands>,
   }
   
   #[derive(Subcommand)]
   pub enum Commands {
       /// 启动内核
       Start,
       /// 列出已注册的模块
       ListModules,
       /// 查看路由表
       Routes,
       /// 查看统计信息
       Stats,
       /// 发送路由请求
       Route {
           #[arg(short, long)]
           action: String,
           #[arg(short, long)]
           params: Option<String>,
       },
   }
   ```
3. 实现各个命令的处理逻辑
4. 支持非交互模式

**验收标准**:
- [ ] 命令行解析正确
- [ ] 所有命令可用
- [ ] 帮助信息完整
- [ ] 单元测试通过

---

### Task 6.6: 实现 IPC 接口

**任务描述**: 实现进程间通信接口。

**详细步骤**:
1. 创建 `src/api/ipc.rs` 文件
2. 选择 IPC 方案（Unix Socket / Named Pipe）
3. 实现 `IpcServer`:
   ```rust
   pub struct IpcServer {
       socket_path: PathBuf,
       core: Arc<ChipsCore>,
   }
   
   impl IpcServer {
       pub async fn start(&self) -> Result<()> {
           let listener = UnixListener::bind(&self.socket_path)?;
           
           loop {
               let (stream, _) = listener.accept().await?;
               let core = Arc::clone(&self.core);
               
               tokio::spawn(async move {
                   Self::handle_connection(stream, core).await;
               });
           }
       }
       
       async fn handle_connection(stream: UnixStream, core: Arc<ChipsCore>) {
           // 处理请求
       }
   }
   ```
4. 实现 `IpcClient` 用于测试
5. 定义 IPC 消息协议

**验收标准**:
- [ ] IPC 服务正常启动
- [ ] 请求响应正确
- [ ] 跨平台支持
- [ ] 单元测试通过

---

### Task 6.7: 实现 Builder 模式 API

**任务描述**: 为复杂配置实现 Builder 模式。

**详细步骤**:
1. 实现 `CoreConfigBuilder`:
   ```rust
   pub struct CoreConfigBuilder {
       config_path: Option<PathBuf>,
       module_dirs: Vec<PathBuf>,
       router_config: RouterConfig,
       logging_config: LogConfig,
   }
   
   impl CoreConfigBuilder {
       pub fn new() -> Self { ... }
       pub fn config_path(mut self, path: PathBuf) -> Self { ... }
       pub fn module_dir(mut self, path: PathBuf) -> Self { ... }
       pub fn worker_count(mut self, count: usize) -> Self { ... }
       pub fn log_level(mut self, level: &str) -> Self { ... }
       pub fn build(self) -> CoreConfig { ... }
   }
   ```
2. 实现 `RouteRequestBuilder`
3. 实现 `EventBuilder`

**验收标准**:
- [ ] Builder 模式正确实现
- [ ] 链式调用流畅
- [ ] 默认值合理
- [ ] 单元测试通过

---

### Task 6.8: 编写示例代码

**任务描述**: 编写 SDK 使用示例。

**详细步骤**:
1. 创建 `examples/` 目录
2. 编写 `examples/basic_usage.rs`:
   ```rust
   //! 基本使用示例
   
   use chips_core::{ChipsCore, CoreConfig, RouteRequest};
   
   #[tokio::main]
   async fn main() -> Result<(), Box<dyn std::error::Error>> {
       // 创建内核实例
       let config = CoreConfig::builder()
           .config_path("config/default.yaml")
           .log_level("info")
           .build();
       
       let core = ChipsCore::new(config).await?;
       
       // 发送路由请求
       let response = core.route_action("example", "test.action", json!({})).await?;
       println!("Response: {:?}", response);
       
       Ok(())
   }
   ```
3. 编写 `examples/event_example.rs` - 事件示例
4. 编写 `examples/module_example.rs` - 模块示例
5. 编写 `examples/config_example.rs` - 配置示例

**验收标准**:
- [ ] 示例代码可运行
- [ ] 注释清晰
- [ ] 覆盖主要功能

---

### Task 6.9: 编写 JavaScript 绑定（骨架）

**任务描述**: 为 JavaScript/TypeScript 准备绑定骨架。

**详细步骤**:
1. 创建 `bindings/` 目录
2. 设计 JS 绑定接口
3. 准备 napi-rs 或 wasm-bindgen 配置
4. 实现基本骨架（完整实现在后续版本）

**注意**: 本阶段只实现骨架，具体的 JS 绑定在后续版本完善。

**验收标准**:
- [ ] 接口设计完成
- [ ] 骨架代码就位
- [ ] 文档说明清晰

---

### Task 6.10: SDK 集成测试

**任务描述**: 编写 SDK 的集成测试。

**详细步骤**:
1. 创建 `tests/sdk_test.rs`
2. 测试 ChipsCore 完整流程
3. 测试 CLI 命令
4. 测试 IPC 通信
5. 运行所有示例确保可工作

**验收标准**:
- [ ] 集成测试通过
- [ ] 所有示例可运行
- [ ] CLI 命令测试通过

---

## 阶段验收标准

- [ ] ChipsCore SDK 完整
- [ ] CLI 命令行可用
- [ ] IPC 接口可用
- [ ] Builder 模式完整
- [ ] 示例代码完整
- [ ] 单元测试覆盖率 > 80%
- [ ] 集成测试通过

---

## 相关文档

- [接口定义](../../技术文档/06-接口定义.md)
- [用户故事](../../需求文档/03-用户故事.md)

---

**创建日期**: 2026-02-01  
**最后更新**: 2026-02-01
