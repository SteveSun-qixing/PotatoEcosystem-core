# Phase 4: 事件总线与配置管理

**阶段状态**: 待开始  
**预计任务数**: 10 个  
**关键依赖**: Phase 2, Phase 3 完成

---

## 阶段目标

实现事件总线和配置管理系统，提供模块间的松耦合通信机制和统一的配置管理能力。

---

## 任务列表

### Task 4.1: 实现事件总线核心

**任务描述**: 实现事件总线的核心数据结构和逻辑。

**详细步骤**:
1. 创建 `src/router/event_bus.rs` 文件
2. 实现 `EventBus` 结构体:
   ```rust
   pub struct EventBus {
       subscriptions: Arc<RwLock<HashMap<String, Vec<Subscription>>>>,
       event_queue: Arc<RequestQueue>,
   }
   ```
3. 实现 `Subscription` 结构体:
   ```rust
   pub struct Subscription {
       pub subscriber_id: String,
       pub event_type: String,
       pub filter: Option<EventFilter>,
       pub callback: Box<dyn Fn(Event) + Send + Sync>,
   }
   ```
4. 实现 `EventFilter` 用于事件过滤

**验收标准**:
- [ ] 数据结构完整
- [ ] 线程安全
- [ ] 单元测试通过

---

### Task 4.2: 实现事件发布

**任务描述**: 实现事件发布功能。

**详细步骤**:
1. 实现 `publish()` 方法:
   ```rust
   pub async fn publish(&self, event: Event) -> Result<()> {
       let event_type = &event.event_type;
       let subscriptions = self.subscriptions.read().await;
       
       if let Some(subs) = subscriptions.get(event_type) {
           for sub in subs {
               if self.matches_filter(&event, &sub.filter) {
                   // 异步发送，不阻塞
                   let event_clone = event.clone();
                   tokio::spawn(async move {
                       (sub.callback)(event_clone);
                   });
               }
           }
       }
       
       Ok(())
   }
   ```
2. 实现 `publish_sync()` - 同步发布（等待所有处理完成）
3. 实现事件过滤匹配逻辑
4. 记录事件日志

**验收标准**:
- [ ] 异步发布不阻塞
- [ ] 过滤器正确匹配
- [ ] 日志记录完整
- [ ] 单元测试通过

---

### Task 4.3: 实现事件订阅

**任务描述**: 实现事件订阅和取消订阅功能。

**详细步骤**:
1. 实现 `subscribe()` 方法:
   ```rust
   pub async fn subscribe(
       &self,
       subscriber_id: &str,
       event_type: &str,
       filter: Option<EventFilter>,
       callback: impl Fn(Event) + Send + Sync + 'static,
   ) -> Result<String> {
       let subscription_id = generate_id();
       // ...
   }
   ```
2. 实现 `unsubscribe()` - 取消特定订阅
3. 实现 `unsubscribe_all()` - 取消模块的所有订阅
4. 返回订阅 ID 用于后续取消

**验收标准**:
- [ ] 订阅功能正确
- [ ] 取消订阅正确
- [ ] 返回有效的订阅 ID
- [ ] 单元测试通过

---

### Task 4.4: 实现事件并发分发

**任务描述**: 实现事件的并发分发机制。

**详细步骤**:
1. 使用 `tokio::spawn` 并发分发事件
2. 实现订阅者隔离（一个订阅者的错误不影响其他）
3. 实现超时控制（单个订阅者处理超时）
4. 记录分发统计

**代码示例**:
```rust
async fn dispatch_event(&self, event: Event, subscriptions: &[Subscription]) {
    let tasks: Vec<_> = subscriptions
        .iter()
        .filter(|sub| self.matches_filter(&event, &sub.filter))
        .map(|sub| {
            let event_clone = event.clone();
            let callback = sub.callback.clone();
            tokio::spawn(async move {
                tokio::time::timeout(
                    Duration::from_secs(5),
                    async { callback(event_clone) }
                ).await
            })
        })
        .collect();
    
    futures::future::join_all(tasks).await;
}
```

**验收标准**:
- [ ] 并发分发正确
- [ ] 订阅者隔离有效
- [ ] 超时控制正常
- [ ] 单元测试通过

---

### Task 4.5: 实现配置文件加载

**任务描述**: 实现配置文件的加载功能。

**详细步骤**:
1. 创建 `src/core/config.rs` 文件
2. 实现 `ConfigManager` 结构体
3. 实现 `load()` 方法 - 从文件加载配置
4. 支持 YAML 和 JSON 格式
5. 支持从多个路径加载
6. 实现配置验证

**代码示例**:
```rust
pub struct ConfigManager {
    config: Arc<RwLock<Config>>,
    config_paths: Vec<PathBuf>,
    watchers: Arc<RwLock<HashMap<String, Vec<ConfigWatcher>>>>,
}

impl ConfigManager {
    pub async fn load(&mut self) -> Result<()> {
        let mut builder = config::Config::builder();
        
        // 加载默认配置
        builder = builder.add_source(
            config::File::with_name("config/default").required(false)
        );
        
        // 加载环境特定配置
        let env = std::env::var("CHIPS_ENV").unwrap_or_else(|_| "development".to_string());
        builder = builder.add_source(
            config::File::with_name(&format!("config/{}", env)).required(false)
        );
        
        // 加载本地覆盖配置
        builder = builder.add_source(
            config::File::with_name("config/local").required(false)
        );
        
        // 环境变量覆盖
        builder = builder.add_source(
            config::Environment::with_prefix("CHIPS")
        );
        
        let config = builder.build()?;
        *self.config.write().await = config;
        
        Ok(())
    }
}
```

**验收标准**:
- [ ] YAML 配置正确加载
- [ ] JSON 配置正确加载
- [ ] 多路径加载正确
- [ ] 验证错误提示清晰
- [ ] 单元测试通过

---

### Task 4.6: 实现配置层级覆盖

**任务描述**: 实现配置的层级覆盖机制。

**详细步骤**:
1. 定义配置层级:
   - 默认配置 (最低优先级)
   - 系统配置
   - 用户配置
   - 环境变量 (最高优先级)
2. 实现层级合并逻辑
3. 后面的配置覆盖前面的
4. 支持深层嵌套的覆盖

**验收标准**:
- [ ] 层级顺序正确
- [ ] 覆盖逻辑正确
- [ ] 深层嵌套正确处理
- [ ] 单元测试通过

---

### Task 4.7: 实现配置读写 API

**任务描述**: 实现配置的读写 API。

**详细步骤**:
1. 实现 `get()` - 读取配置值:
   ```rust
   pub fn get<T: DeserializeOwned>(&self, key: &str) -> Option<T>;
   pub fn get_or<T: DeserializeOwned>(&self, key: &str, default: T) -> T;
   ```
2. 实现 `set()` - 设置配置值
3. 实现 `save()` - 持久化配置
4. 支持嵌套路径访问（如 `router.worker_count`）
5. 支持类型转换

**代码示例**:
```rust
impl ConfigManager {
    pub fn get<T: DeserializeOwned>(&self, key: &str) -> Option<T> {
        let config = self.config.read().blocking_lock();
        config.get::<T>(key).ok()
    }

    pub fn get_or<T: DeserializeOwned>(&self, key: &str, default: T) -> T {
        self.get(key).unwrap_or(default)
    }

    pub async fn set<T: Serialize>(&self, key: &str, value: T) -> Result<()> {
        // 更新内存中的配置
        // 触发变更通知
    }
}
```

**验收标准**:
- [ ] 读取功能正确
- [ ] 写入功能正确
- [ ] 嵌套路径访问正确
- [ ] 类型转换正确
- [ ] 单元测试通过

---

### Task 4.8: 实现配置变更监听

**任务描述**: 实现配置变更的监听机制。

**详细步骤**:
1. 实现 `on_change()` - 注册变更监听器
2. 实现 `off_change()` - 取消监听
3. 配置变更时通知所有监听器
4. 支持监听特定配置路径

**代码示例**:
```rust
impl ConfigManager {
    pub fn on_change(
        &self,
        path: &str,
        callback: impl Fn(&Config) + Send + Sync + 'static,
    ) -> String {
        let watcher_id = generate_id();
        // 注册监听器
        watcher_id
    }

    async fn notify_change(&self, changed_path: &str) {
        let watchers = self.watchers.read().await;
        for (path, callbacks) in watchers.iter() {
            if changed_path.starts_with(path) {
                for callback in callbacks {
                    let config = self.config.read().await;
                    callback(&config);
                }
            }
        }
    }
}
```

**验收标准**:
- [ ] 变更监听正确
- [ ] 取消监听正确
- [ ] 路径匹配正确
- [ ] 单元测试通过

---

### Task 4.9: 实现配置热更新

**任务描述**: 实现配置文件的热更新功能。

**详细步骤**:
1. 使用文件系统监控（notify crate）
2. 监控配置文件变化
3. 文件变化时自动重新加载
4. 通知相关监听器
5. 处理加载错误（不影响当前配置）

**注意**: 某些配置可能需要重启才能生效，需要在文档中说明。

**验收标准**:
- [ ] 文件监控正常
- [ ] 自动重新加载正确
- [ ] 错误处理完善
- [ ] 单元测试通过

---

### Task 4.10: 事件和配置系统集成测试

**任务描述**: 编写事件总线和配置管理的集成测试。

**详细步骤**:
1. 创建 `tests/event_config_test.rs`
2. 测试事件发布订阅:
   - 正常发布订阅流程
   - 过滤器测试
   - 并发发布测试
   - 订阅者错误隔离测试
3. 测试配置管理:
   - 配置加载测试
   - 层级覆盖测试
   - 读写测试
   - 变更监听测试

**验收标准**:
- [ ] 集成测试覆盖所有场景
- [ ] 所有测试通过

---

## 阶段验收标准

- [ ] EventBus 功能完整
- [ ] ConfigManager 功能完整
- [ ] 事件发布订阅正常
- [ ] 配置层级覆盖正确
- [ ] 配置变更监听正常
- [ ] 单元测试覆盖率 > 85%
- [ ] 集成测试通过

---

## 相关文档

- [薯片协议规范](../../../生态共用/01-薯片协议规范.md) (事件消息部分)
- [架构设计](../../技术文档/01-架构设计.md)

---

**创建日期**: 2026-02-01  
**最后更新**: 2026-02-01
