# Phase 3: 模块管理系统

**阶段状态**: 待开始  
**预计任务数**: 13 个  
**关键依赖**: Phase 2 完成

---

## 阶段目标

实现模块管理系统，负责模块的整个生命周期管理，包括扫描、注册、加载、卸载、依赖解析、版本管理、健康检查等。

---

## 任务列表

### Task 3.1: 实现模块元数据解析器

**任务描述**: 实现从 module.yaml 文件解析模块元数据。

**详细步骤**:
1. 创建 `src/module/parser.rs` 文件
2. 实现 `ModuleParser` 结构体
3. 实现 `parse_file()` - 从文件解析
4. 实现 `parse_string()` - 从字符串解析
5. 实现完整的数据验证:
   - 必填字段检查
   - 版本号格式验证
   - 依赖声明验证
   - 权限声明验证
6. 返回详细的解析错误信息

**代码示例**:
```rust
pub struct ModuleParser;

impl ModuleParser {
    pub async fn parse_file(path: &Path) -> Result<ModuleMetadata> {
        let content = tokio::fs::read_to_string(path).await?;
        Self::parse_string(&content)
    }

    pub fn parse_string(content: &str) -> Result<ModuleMetadata> {
        let metadata: ModuleMetadata = serde_yaml::from_str(content)?;
        Self::validate(&metadata)?;
        Ok(metadata)
    }

    fn validate(metadata: &ModuleMetadata) -> Result<()> {
        // 验证必填字段
        if metadata.id.is_empty() {
            return Err(Error::InvalidMetadata("id is required".to_string()));
        }
        // ...更多验证
        Ok(())
    }
}
```

**验收标准**:
- [ ] 能正确解析 module.yaml
- [ ] 验证所有必填字段
- [ ] 详细的错误消息
- [ ] 单元测试通过

**参考文档**:
- `技术文档/03-模块管理系统设计.md` (module.yaml 格式)

---

### Task 3.2: 实现模块注册表

**任务描述**: 实现模块注册表，管理所有已注册的模块。

**详细步骤**:
1. 创建 `src/module/registry.rs` 文件
2. 实现 `ModuleRegistry` 结构体:
   ```rust
   pub struct ModuleRegistry {
       modules: Arc<RwLock<HashMap<String, ModuleInfo>>>,
       states: Arc<RwLock<HashMap<String, ModuleState>>>,
       module_dirs: Vec<PathBuf>,
   }
   ```
3. 实现 `scan()` - 扫描模块目录
4. 实现 `register()` - 注册单个模块
5. 实现 `unregister()` - 取消注册
6. 实现 `get_module()` - 获取模块信息
7. 实现 `list_modules()` - 列出所有模块
8. 实现 `get_state()`/`set_state()` - 状态管理
9. 实现 `exists()` - 检查模块是否存在
10. 实现 `find_modules()` - 按条件查找

**验收标准**:
- [ ] 注册表操作完整
- [ ] 线程安全
- [ ] 状态管理正确
- [ ] 单元测试通过

---

### Task 3.3: 实现依赖图

**任务描述**: 实现模块依赖关系图。

**详细步骤**:
1. 创建 `src/module/dependency.rs` 文件
2. 实现 `DependencyGraph` 结构体:
   ```rust
   pub struct DependencyGraph {
       edges: HashMap<String, Vec<String>>,
       reverse_edges: HashMap<String, Vec<String>>,
   }
   ```
3. 实现 `add_dependency()` - 添加依赖关系
4. 实现 `remove_dependency()` - 移除依赖关系
5. 实现 `get_dependencies()` - 获取模块的依赖
6. 实现 `get_dependents()` - 获取依赖该模块的模块
7. 实现 `has_cycle()` - 检测循环依赖（DFS）
8. 实现 `topological_sort()` - 拓扑排序（Kahn算法）
9. 实现 `clear()` - 清空图

**代码示例**:
```rust
impl DependencyGraph {
    pub fn has_cycle(&self) -> bool {
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();
        
        for node in self.edges.keys() {
            if self.has_cycle_util(node, &mut visited, &mut rec_stack) {
                return true;
            }
        }
        false
    }

    pub fn topological_sort(&self) -> Result<Vec<String>> {
        if self.has_cycle() {
            return Err(Error::CircularDependency);
        }
        // Kahn算法实现
    }
}
```

**验收标准**:
- [ ] 依赖关系正确管理
- [ ] 循环依赖检测正确
- [ ] 拓扑排序正确
- [ ] 单元测试通过

---

### Task 3.4: 实现依赖解析器

**任务描述**: 实现模块依赖解析器。

**详细步骤**:
1. 实现 `DependencyResolver` 结构体
2. 实现 `resolve()` - 解析模块的所有依赖
3. 实现 `resolve_recursive()` - 递归解析
4. 实现版本兼容性检查:
   - 使用 semver 库
   - 支持 `^`, `~`, `>=`, `<` 等范围
5. 实现 `check_conflicts()` - 检查依赖冲突
6. 返回加载顺序列表

**代码示例**:
```rust
impl DependencyResolver {
    pub async fn resolve(&self, module_id: &str) -> Result<Vec<String>> {
        let mut resolved = Vec::new();
        let mut visited = HashSet::new();
        
        self.resolve_recursive(module_id, &mut resolved, &mut visited).await?;
        
        Ok(resolved)
    }

    async fn resolve_recursive(
        &self,
        module_id: &str,
        resolved: &mut Vec<String>,
        visited: &mut HashSet<String>,
    ) -> Result<()> {
        // 检测循环依赖
        if visited.contains(module_id) {
            if !resolved.contains(&module_id.to_string()) {
                return Err(Error::CircularDependency(module_id.to_string()));
            }
            return Ok(());
        }
        
        visited.insert(module_id.to_string());
        
        // 获取并解析依赖
        // ...
    }
}
```

**验收标准**:
- [ ] 依赖解析正确
- [ ] 版本兼容性检查正确
- [ ] 冲突检测正确
- [ ] 单元测试通过

---

### Task 3.5: 实现模块加载器

**任务描述**: 实现模块加载器，负责实际加载模块代码。

**详细步骤**:
1. 创建 `src/module/loader.rs` 文件
2. 实现 `ModuleLoader` 结构体
3. 实现 `load()` 方法:
   1. 检查模块是否已加载
   2. 设置状态为 Loading
   3. 解析依赖
   4. 递归加载依赖
   5. 加载模块代码
   6. 初始化模块
   7. 设置状态为 Running
4. 实现 `unload()` 方法:
   1. 检查是否有其他模块依赖
   2. 调用模块的 cleanup
   3. 移除路由规则
   4. 取消事件订阅
   5. 释放资源
   6. 设置状态为 Unloaded

**验收标准**:
- [ ] 加载流程完整
- [ ] 卸载流程完整
- [ ] 状态管理正确
- [ ] 错误处理完善
- [ ] 单元测试通过

---

### Task 3.6: 实现运行时管理器接口

**任务描述**: 定义运行时管理器的 trait 接口。

**详细步骤**:
1. 创建 `src/module/runtime/mod.rs` 文件
2. 定义 `RuntimeManager` trait:
   ```rust
   #[async_trait]
   pub trait RuntimeManager: Send + Sync {
       async fn load_module(&self, module_info: &ModuleInfo) -> Result<ModuleInstance>;
       async fn unload_module(&self, module_id: &str) -> Result<()>;
       fn runtime_type(&self) -> Runtime;
   }
   ```
3. 定义 `ModuleInstance` 结构体
4. 定义 `ModuleHandle` 枚举

**验收标准**:
- [ ] trait 定义完整
- [ ] 接口设计合理
- [ ] 文档注释完整

---

### Task 3.7: 实现 JavaScript 运行时管理器（骨架）

**任务描述**: 实现 JavaScript 运行时管理器的基本骨架。

**详细步骤**:
1. 创建 `src/module/runtime/js.rs` 文件
2. 实现 `JsRuntimeManager` 结构体
3. 实现 `RuntimeManager` trait（基本骨架）
4. 预留 V8/Deno 集成点
5. 后续版本完善具体实现

**注意**: 本阶段只实现骨架，具体的 JavaScript 执行能力在后续版本实现。

**验收标准**:
- [ ] 结构体定义完整
- [ ] trait 实现骨架
- [ ] 预留扩展点

---

### Task 3.8: 实现模块实例管理

**任务描述**: 实现模块实例的管理。

**详细步骤**:
1. 实现 `ModuleInstance` 结构体:
   ```rust
   pub struct ModuleInstance {
       pub id: String,
       pub runtime: Runtime,
       pub handle: ModuleHandle,
       pub started_at: DateTime<Utc>,
   }
   ```
2. 实现 `initialize()` - 初始化模块
3. 实现 `call_method()` - 调用模块方法
4. 实现 `cleanup()` - 清理模块
5. 实现实例池管理

**验收标准**:
- [ ] 实例管理完整
- [ ] 方法调用正确
- [ ] 生命周期管理正确
- [ ] 单元测试通过

---

### Task 3.9: 实现生命周期管理器

**任务描述**: 实现模块生命周期管理器。

**详细步骤**:
1. 创建 `src/module/lifecycle.rs` 文件
2. 实现 `LifecycleManager` 结构体
3. 实现生命周期钩子:
   - `on_init` - 初始化
   - `on_start` - 启动
   - `on_stop` - 停止
   - `on_cleanup` - 清理
4. 实现 `start()` - 启动模块
5. 实现 `stop()` - 停止模块
6. 实现 `restart()` - 重启模块

**验收标准**:
- [ ] 生命周期钩子正确调用
- [ ] 状态转换正确
- [ ] 单元测试通过

---

### Task 3.10: 实现健康检查

**任务描述**: 实现模块健康检查功能。

**详细步骤**:
1. 定义 `HealthStatus` 结构体:
   ```rust
   pub struct HealthStatus {
       pub status: String, // "healthy" | "degraded" | "unhealthy"
       pub details: HashMap<String, Value>,
   }
   ```
2. 实现 `health_check()` - 单个模块检查
3. 实现 `health_check_all()` - 检查所有模块
4. 实现定时健康检查任务
5. 实现异常恢复逻辑

**代码示例**:
```rust
impl LifecycleManager {
    pub async fn start_health_check_loop(&self) {
        let interval = Duration::from_secs(30);
        
        loop {
            tokio::time::sleep(interval).await;
            
            let instances = self.instances.read().await;
            for (module_id, instance) in instances.iter() {
                match instance.call_method("onHealthCheck", json!({})).await {
                    Ok(_) => {},
                    Err(e) => {
                        error!(module_id = %module_id, error = ?e, "Health check failed");
                        // 尝试重启
                    }
                }
            }
        }
    }
}
```

**验收标准**:
- [ ] 健康检查正常工作
- [ ] 定时任务正常运行
- [ ] 异常恢复正确
- [ ] 单元测试通过

---

### Task 3.11: 实现热插拔支持

**任务描述**: 实现模块热安装、热更新、热卸载功能。

**详细步骤**:
1. 实现 `hot_install()` - 运行时安装模块
2. 实现 `hot_update()` - 运行时更新模块
3. 实现 `hot_unload()` - 运行时卸载模块
4. 实现状态保存和恢复
5. 触发相应事件通知

**代码示例**:
```rust
impl ModuleManager {
    pub async fn hot_install(&self, module_path: &Path) -> Result<String> {
        // 1. 注册模块
        let module_id = self.registry.register(module_path).await?;
        
        // 2. 加载模块
        self.loader.load(&module_id).await?;
        
        // 3. 注册路由
        self.register_routes(&module_id).await?;
        
        // 4. 发送事件
        self.event_bus.publish(Event {
            event_type: "module.installed".to_string(),
            data: json!({ "module_id": module_id }),
            ..Default::default()
        }).await;
        
        Ok(module_id)
    }
}
```

**验收标准**:
- [ ] 热安装正常工作
- [ ] 热更新正常工作
- [ ] 热卸载正常工作
- [ ] 状态保存恢复正确
- [ ] 单元测试通过

---

### Task 3.12: 实现 ModuleManager 主结构体

**任务描述**: 实现 ModuleManager 主结构体，整合所有模块管理组件。

**详细步骤**:
1. 创建 `src/module/manager.rs` 文件
2. 实现 `ModuleManager` 结构体:
   ```rust
   pub struct ModuleManager {
       registry: Arc<ModuleRegistry>,
       loader: Arc<ModuleLoader>,
       lifecycle: Arc<LifecycleManager>,
       dependency_resolver: Arc<DependencyResolver>,
       router: Arc<Router>, // 用于注册路由
       event_bus: Arc<EventBus>, // 用于发送事件
   }
   ```
3. 实现 `new()` 构造函数
4. 实现高层 API:
   - `load_module()`
   - `unload_module()`
   - `get_module_info()`
   - `list_modules()`
5. 与 Router 集成，自动注册/注销路由

**验收标准**:
- [ ] ModuleManager 功能完整
- [ ] 与 Router 正确集成
- [ ] API 设计合理
- [ ] 单元测试通过

---

### Task 3.13: 模块管理系统集成测试

**任务描述**: 编写模块管理系统的集成测试。

**详细步骤**:
1. 创建 `tests/module_integration_test.rs`
2. 创建测试用模块目录和模块文件
3. 测试场景:
   - 模块扫描和注册
   - 模块加载和卸载
   - 依赖解析
   - 循环依赖检测
   - 版本兼容性检查
   - 热插拔
   - 健康检查
4. 测试边界情况和错误处理

**验收标准**:
- [ ] 集成测试覆盖所有场景
- [ ] 所有测试通过
- [ ] 边界情况处理正确

---

## 阶段验收标准

- [ ] ModuleRegistry 功能完整
- [ ] DependencyResolver 功能完整
- [ ] ModuleLoader 功能完整
- [ ] LifecycleManager 功能完整
- [ ] 热插拔支持
- [ ] 健康检查正常
- [ ] 单元测试覆盖率 > 90%
- [ ] 集成测试通过

---

## 相关文档

- [模块管理系统设计](../../技术文档/03-模块管理系统设计.md)
- [数据结构设计](../../技术文档/07-数据结构设计.md)

---

**创建日期**: 2026-02-01  
**最后更新**: 2026-02-01
