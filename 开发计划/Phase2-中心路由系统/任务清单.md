# Phase 2: 中心路由系统

**阶段状态**: 待开始  
**预计任务数**: 14 个  
**关键依赖**: Phase 1 完成

---

## 阶段目标

实现薯片微内核的核心功能——中心路由系统。这是整个生态架构最关键的部分，确保所有模块通过统一的路由进行交互。

---

## 任务列表

### Task 2.1: 实现路由表核心逻辑

**任务描述**: 实现 RouteTable 的完整功能。

**详细步骤**:
1. 实现 `RouteTable::new()` 构造函数
2. 实现 `register_action_route()` - 注册 action 路由
3. 实现 `register_custom_route()` - 注册自定义正则路由
4. 实现 `find_route()` - 查找路由
5. 实现 `remove_module_routes()` - 移除模块的所有路由
6. 实现 `update_priority()` - 更新路由优先级
7. 实现 `export()` - 导出路由表（用于调试）
8. 使用 `RwLock` 保护并发访问

**代码示例**:
```rust
impl RouteTable {
    pub fn new() -> Self {
        Self {
            action_routes: Arc::new(RwLock::new(HashMap::new())),
            custom_routes: Arc::new(RwLock::new(Vec::new())),
            default_route: Arc::new(RwLock::new(None)),
        }
    }

    pub async fn find_route(&self, request: &RouteRequest) -> Option<RouteEntry> {
        // 1. 查找自定义路由
        // 2. 查找 action 路由
        // 3. 返回默认路由
    }
}
```

**验收标准**:
- [ ] 所有路由表操作实现
- [ ] 线程安全（使用 RwLock）
- [ ] 查找性能 O(1) 或 O(log n)
- [ ] 单元测试覆盖率 > 90%

**参考文档**:
- `技术文档/02-中心路由系统设计.md`

---

### Task 2.2: 实现请求验证器

**任务描述**: 实现请求格式和权限的验证逻辑。

**详细步骤**:
1. 创建 `src/router/validator.rs` 文件
2. 实现 `RequestValidator` 结构体
3. 实现 `validate_format()` - 验证请求格式:
   - 检查 request_id 非空
   - 检查 sender 非空
   - 检查 action 非空且格式正确
   - 检查 timestamp 有效
4. 实现 `validate_permission()` - 验证权限
5. 返回详细的验证错误信息

**验收标准**:
- [ ] 所有必填字段验证
- [ ] 格式验证（action 格式）
- [ ] 清晰的错误消息
- [ ] 单元测试通过

**参考文档**:
- `生态共用/01-薯片协议规范.md`

---

### Task 2.3: 实现优先级请求队列

**任务描述**: 实现基于优先级的请求队列。

**详细步骤**:
1. 创建 `src/router/queue.rs` 文件
2. 实现 `RequestQueue` 结构体:
   - 使用 `BinaryHeap` 实现优先级队列
   - 使用 `Mutex` 保护并发访问
   - 使用 `Notify` 实现等待通知
3. 实现 `enqueue()` - 入队
4. 实现 `dequeue()` - 出队（阻塞）
5. 实现 `try_dequeue()` - 尝试出队（非阻塞）
6. 实现 `size()` - 队列大小
7. 实现 `is_full()` - 队列是否已满
8. 实现 `QueueItem` 结构体

**代码示例**:
```rust
pub struct RequestQueue {
    queue: Arc<Mutex<BinaryHeap<PriorityQueueItem>>>,
    max_size: usize,
    current_size: Arc<AtomicUsize>,
    notify: Arc<Notify>,
}

pub struct QueueItem {
    pub request: RouteRequest,
    pub target_module: String,
    pub response_tx: oneshot::Sender<RouteResponse>,
    pub enqueued_at: Instant,
}
```

**验收标准**:
- [ ] 优先级排序正确
- [ ] 线程安全
- [ ] 阻塞和非阻塞操作正常
- [ ] 单元测试通过

---

### Task 2.4: 实现路由查找算法

**任务描述**: 实现完整的路由查找算法。

**详细步骤**:
1. 实现 `Router::find_target_module()` 方法
2. 查找顺序:
   1. 如果请求指定了 target，直接使用
   2. 查找自定义路由（最高优先级）
   3. 查找 action 路由
   4. 使用默认路由
3. 实现 `find_best_entry()` - 从多个路由中选择最佳
4. 处理路由未找到的情况

**代码示例**:
```rust
pub fn find_target_module(&self, request: &RouteRequest) -> Result<String> {
    // 1. 检查 target
    if let Some(ref target) = request.target {
        if self.module_exists(target) {
            return Ok(target.clone());
        }
        return Err(Error::ModuleNotFound(target.clone()));
    }

    // 2. 查找自定义路由
    // 3. 查找 action 路由
    // 4. 默认路由
}
```

**验收标准**:
- [ ] 查找顺序正确
- [ ] 优先级处理正确
- [ ] 边界情况处理
- [ ] 单元测试通过

---

### Task 2.5: 实现请求转发机制

**任务描述**: 实现将请求转发到目标模块的机制。

**详细步骤**:
1. 创建 `src/router/dispatcher.rs` 文件
2. 实现 `RequestDispatcher` 结构体
3. 实现 `dispatch()` 方法:
   - 创建 oneshot channel 用于接收响应
   - 将请求放入队列
   - 等待响应或超时
4. 实现 `dispatch_to_module()` - 实际转发逻辑
5. 处理模块不可用的情况

**验收标准**:
- [ ] 请求正确转发
- [ ] 响应正确返回
- [ ] 错误处理完善
- [ ] 单元测试通过

---

### Task 2.6: 实现超时处理

**任务描述**: 实现请求超时处理机制。

**详细步骤**:
1. 使用 `tokio::time::timeout` 包装请求处理
2. 实现可配置的超时时间（默认 30 秒）
3. 超时后生成超时响应
4. 记录超时日志
5. 实现取消机制（CancellationToken）

**代码示例**:
```rust
async fn route_with_timeout(&self, request: RouteRequest) -> RouteResponse {
    let timeout_duration = Duration::from_millis(request.timeout_ms);
    
    match tokio::time::timeout(timeout_duration, self.process_request(request.clone())).await {
        Ok(response) => response,
        Err(_) => RouteResponse::error(
            &request.request_id,
            StatusCode::TIMEOUT,
            ErrorInfo::new("TIMEOUT", "Request timeout"),
            timeout_duration.as_millis() as u64,
        ),
    }
}
```

**验收标准**:
- [ ] 超时机制正常工作
- [ ] 超时时间可配置
- [ ] 超时响应格式正确
- [ ] 单元测试通过

---

### Task 2.7: 实现并发控制

**任务描述**: 实现并发请求数量控制。

**详细步骤**:
1. 使用 `Semaphore` 限制并发数
2. 实现 `ConcurrencyLimiter` 结构体
3. 默认并发数：CPU 核心数 × 2
4. 提供配置接口调整并发数
5. 记录当前并发数

**代码示例**:
```rust
pub struct ConcurrencyLimiter {
    semaphore: Arc<Semaphore>,
    max_concurrency: usize,
}

impl ConcurrencyLimiter {
    pub async fn acquire(&self) -> SemaphorePermit<'_> {
        self.semaphore.acquire().await.unwrap()
    }

    pub fn current_concurrency(&self) -> usize {
        self.max_concurrency - self.semaphore.available_permits()
    }
}
```

**验收标准**:
- [ ] 并发数限制有效
- [ ] 可配置并发数
- [ ] 监控当前并发数
- [ ] 单元测试通过

---

### Task 2.8: 实现工作线程池

**任务描述**: 实现处理请求的工作线程池。

**详细步骤**:
1. 创建 `src/router/processor.rs` 文件
2. 实现 `RouteProcessor` 结构体
3. 实现 `start()` - 启动工作线程
4. 实现 `worker_loop()` - 工作线程循环
5. 实现优雅关闭机制

**代码示例**:
```rust
pub struct RouteProcessor {
    worker_count: usize,
    workers: Vec<JoinHandle<()>>,
    shutdown: Arc<AtomicBool>,
}

impl RouteProcessor {
    pub fn start(&mut self, queue: Arc<RequestQueue>, router: Arc<Router>) {
        for i in 0..self.worker_count {
            let queue = Arc::clone(&queue);
            let router = Arc::clone(&router);
            let shutdown = Arc::clone(&self.shutdown);
            
            let handle = tokio::spawn(async move {
                while !shutdown.load(Ordering::Relaxed) {
                    if let Some(item) = queue.dequeue().await {
                        let response = router.process_request(item.request).await;
                        let _ = item.response_tx.send(response);
                    }
                }
            });
            
            self.workers.push(handle);
        }
    }
}
```

**验收标准**:
- [ ] 工作线程正常启动
- [ ] 请求并发处理
- [ ] 优雅关闭
- [ ] 单元测试通过

---

### Task 2.9: 实现 Router 主结构体

**任务描述**: 实现 Router 主结构体，整合所有路由组件。

**详细步骤**:
1. 创建 `src/router/router.rs` 文件
2. 实现 `Router` 结构体:
   - `route_table: Arc<RouteTable>`
   - `queue: Arc<RequestQueue>`
   - `processor: RouteProcessor`
   - `concurrency_limiter: ConcurrencyLimiter`
   - `stats: RouteStats`
3. 实现 `new()` 构造函数
4. 实现 `route()` - 主路由方法
5. 实现 `register_module()` - 注册模块路由
6. 实现 `unregister_module()` - 注销模块路由

**验收标准**:
- [ ] Router 结构完整
- [ ] 所有组件正确集成
- [ ] 路由流程完整
- [ ] 单元测试通过

---

### Task 2.10: 实现路由日志记录

**任务描述**: 实现路由请求和响应的日志记录。

**详细步骤**:
1. 在 Router 中添加日志记录点
2. 实现 `log_request()` - 记录请求日志
3. 实现 `log_response()` - 记录响应日志
4. 实现 `log_timeout()` - 记录超时日志
5. 使用结构化日志格式（tracing）

**代码示例**:
```rust
fn log_request(&self, request: &RouteRequest, target: &str) {
    info!(
        request_id = %request.request_id,
        sender = %request.sender,
        target = %target,
        action = %request.action,
        "Route request"
    );
}
```

**验收标准**:
- [ ] 所有关键点有日志
- [ ] 日志格式结构化
- [ ] 日志级别正确
- [ ] 可配置日志详细程度

---

### Task 2.11: 实现路由统计

**任务描述**: 实现路由性能统计功能。

**详细步骤**:
1. 实现 `RouteStats` 结构体:
   - `total_requests: AtomicU64`
   - `successful_requests: AtomicU64`
   - `failed_requests: AtomicU64`
   - `total_elapsed_ms: AtomicU64`
   - `min_latency_ms: AtomicU64`
   - `max_latency_ms: AtomicU64`
2. 实现 `record_request()` - 记录请求
3. 实现 `average_latency_ms()` - 计算平均延迟
4. 实现 `success_rate()` - 计算成功率
5. 实现 `export()` - 导出统计数据

**验收标准**:
- [ ] 统计数据准确
- [ ] 线程安全（使用原子操作）
- [ ] 可导出统计报告
- [ ] 单元测试通过

---

### Task 2.12: 实现快速路由（Foundation 优化）

**任务描述**: 为 Foundation 模块实现快速路由通道。

**详细步骤**:
1. 识别 Foundation 模块的特殊路由
2. 实现快速路径，跳过某些检查
3. 减少路由开销
4. 保持功能完整性

**验收标准**:
- [ ] Foundation 路由延迟降低
- [ ] 功能不受影响
- [ ] 单元测试通过

---

### Task 2.13: 实现批量请求支持

**任务描述**: 实现批量请求处理功能。

**详细步骤**:
1. 定义 `BatchRequest` 结构体
2. 实现 `route_batch()` 方法
3. 并行处理批量请求
4. 聚合响应结果

**代码示例**:
```rust
pub async fn route_batch(&self, requests: Vec<RouteRequest>) -> Vec<RouteResponse> {
    let tasks: Vec<_> = requests
        .into_iter()
        .map(|req| self.route(req))
        .collect();
    
    futures::future::join_all(tasks).await
}
```

**验收标准**:
- [ ] 批量请求正确处理
- [ ] 并行执行
- [ ] 响应顺序正确
- [ ] 单元测试通过

---

### Task 2.14: 路由系统集成测试

**任务描述**: 编写路由系统的集成测试。

**详细步骤**:
1. 创建 `tests/router_integration_test.rs`
2. 测试完整的路由流程
3. 测试并发场景
4. 测试超时场景
5. 测试错误处理场景
6. 测试性能（路由延迟 < 10ms）

**验收标准**:
- [ ] 集成测试覆盖所有场景
- [ ] 所有测试通过
- [ ] 路由延迟 < 10ms

---

## 阶段验收标准

- [ ] RouteTable 功能完整
- [ ] Router 主流程实现
- [ ] 并发控制正常
- [ ] 超时处理正常
- [ ] 日志记录完整
- [ ] 性能统计正常
- [ ] 路由延迟 < 10ms (P95)
- [ ] 单元测试覆盖率 > 90%
- [ ] 集成测试通过

---

## 性能要求

- 路由延迟: < 10ms (P95)
- 并发支持: ≥1000 并发请求
- 内存占用: < 10MB (路由系统部分)

---

## 相关文档

- [中心路由系统设计](../../技术文档/02-中心路由系统设计.md)
- [数据结构设计](../../技术文档/07-数据结构设计.md)
- [薯片协议规范](../../../生态共用/01-薯片协议规范.md)

---

**创建日期**: 2026-02-01  
**最后更新**: 2026-02-01
